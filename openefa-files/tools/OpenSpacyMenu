#!/bin/bash
# OpenSpaCy Admin Menu - Enhanced with Trust Levels and Better Error Handling
# Version 2.0 - Complete Implementation

# Check if running as root
if [ "$EUID" -ne 0 ]; then 
    echo "Error: This menu requires root privileges."
    echo "Please run as: sudo $0"
    exit 1
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Config paths
SPACY_ROOT="/opt/spacyserver"
PYTHON="$SPACY_ROOT/venv/bin/python3"
BEC_CONFIG="$SPACY_ROOT/config/bec_config.json"
MODULE_CONFIG="$SPACY_ROOT/config/module_config.json"
FILTER_CONFIG="$SPACY_ROOT/config/email_filter_config.json"
AUTH_CONFIG="$SPACY_ROOT/config/authentication_config.json"
THRESHOLD_CONFIG="$SPACY_ROOT/config/threshold_config.json"
TRUSTED_DOMAINS_CONFIG="$SPACY_ROOT/config/trusted_domains.json"
BACKUP_DIR="$SPACY_ROOT/backups"
LOG_DIR="$SPACY_ROOT/logs"

# Load database configuration from environment
if [[ -f /etc/spacy-server/.env ]]; then
    source /etc/spacy-server/.env
fi
: "${DB_NAME:=spacy_email_db}"
: "${DB_USER:=spacy_user}"

mkdir -p "$BACKUP_DIR" "$LOG_DIR"

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

show_header() {
    clear
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                     ${WHITE}OpenSpaCy Admin Menu${CYAN}                      ║${NC}"
    echo -e "${CYAN}║                   ${MAGENTA}Enhanced Email Security${CYAN}                   ║${NC}"
    echo -e "${CYAN}║                    ${YELLOW}Version 2.0 with Trust Levels${CYAN}             ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

show_main_menu() {
    show_header
    echo -e "${WHITE}Main Menu:${NC}"
    echo ""
    echo -e "${GREEN}Security Management:${NC}"
    echo -e "${YELLOW}1.${NC} BEC Sender Whitelist Management ${RED}[DEPRECATED - Use SpacyWeb]${NC}"
    echo -e "${YELLOW}2.${NC} BEC Domain Whitelist Management ${RED}[DEPRECATED - Use SpacyWeb]${NC}"
    echo -e "${GREEN}3.${NC} Executive Protection Management"
    echo -e "${GREEN}4.${NC} Company Impersonation Protection"
    echo ""
    echo -e "${BLUE}Filter Configuration:${NC}"
    echo -e "${GREEN}5.${NC} Email Filter Management"
    echo -e "${GREEN}6.${NC} Authentication Configuration"
    echo -e "${GREEN}7.${NC} Threshold Management"
    echo ""
    echo -e "${MAGENTA}System Operations:${NC}"
    echo -e "${GREEN}8.${NC} Performance Monitoring"
    echo -e "${GREEN}9.${NC} Real-time Email Analysis"
    echo -e "${GREEN}10.${NC} Backup & Restore"
    echo -e "${GREEN}11.${NC} System Information"
    echo ""
    echo -e "${YELLOW}Maintenance:${NC}"
    echo -e "${GREEN}12.${NC} Validate & Fix JSON Configuration"
    echo -e "${GREEN}13.${NC} Check File Permissions"
    echo -e "${GREEN}14.${NC} Domain Management (Add/Remove Domains)"
    echo -e "${GREEN}15.${NC} DNS Diagnostics & Testing"
    echo -e "${GREEN}16.${NC} Email Blocking Management (MTA blocking - currently disabled, see spam penalties)"
    echo -e "${GREEN}17.${NC} Search Email by Sender"
    echo -e "${GREEN}18.${NC} Trusted Domains Management (Fast-track Whitelist)"
    echo -e "${GREEN}19.${NC} Unified Whitelist Search (Search All Whitelists)"
    echo -e "${GREEN}20.${NC} Conversation Learning Statistics (AI Pattern Learning)"
    echo -e "${GREEN}21.${NC} SpamAssassin Rule Management (Quarantine Feedback)"
    echo -e "${GREEN}22.${NC} Spam Fighting Effectiveness Metrics"
    echo -e "${GREEN}23.${NC} RBL Management (Real-time Blackhole Lists)"
    echo ""
    echo -e "${RED}0.${NC} Exit"
    echo ""
    echo -n -e "${YELLOW}Select option [0-23]: ${NC}"
}

create_backup() {
    local file="$1"
    local description="$2"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local basename=$(basename "$file")
    local backup_file="$BACKUP_DIR/${basename}.backup.$timestamp"

    if [[ -f "$file" ]]; then
        cp "$file" "$backup_file"
        echo -e "${GREEN}✓${NC} Backup created: $backup_file"
        if [[ -n "$description" ]]; then
            echo -e "${BLUE}  $description${NC}"
        fi
        return 0
    else
        echo -e "${RED}✗${NC} File not found: $file"
        return 1
    fi
}

pause_for_user() {
    echo ""
    echo -n -e "${YELLOW}Press Enter to continue...${NC}"
    read
}

validate_json() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}File not found: $file${NC}"
        return 1
    fi
    
    if jq '.' "$file" >/dev/null 2>&1; then
        echo -e "${GREEN}✓ JSON is valid${NC}"
        return 0
    else
        echo -e "${RED}✗ JSON has errors:${NC}"
        jq '.' "$file" 2>&1 | head -20
        return 1
    fi
}

check_permissions() {
    local file="$1"
    local expected_owner="spacy-filter:spacy-filter"
    local expected_perms="664"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${YELLOW}File not found: $file${NC}"
        return 1
    fi
    
    local current_owner=$(stat -c '%U:%G' "$file" 2>/dev/null)
    local current_perms=$(stat -c '%a' "$file" 2>/dev/null)
    
    echo -e "${BLUE}File: $(basename $file)${NC}"
    echo -e "  Owner: $current_owner (expected: $expected_owner)"
    echo -e "  Permissions: $current_perms (expected: $expected_perms)"
    
    if [[ "$current_owner" != "$expected_owner" ]] || [[ "$current_perms" != "$expected_perms" ]]; then
        echo -e "${YELLOW}  ⚠ Permissions need fixing${NC}"
        return 1
    else
        echo -e "${GREEN}  ✓ Permissions correct${NC}"
        return 0
    fi
}

fix_permissions() {
    local file="$1"
    if [[ -f "$file" ]]; then
        sudo chown spacy-filter:spacy-filter "$file"
        sudo chmod 664 "$file"
        echo -e "${GREEN}✓ Fixed permissions for $(basename $file)${NC}"
    fi
}

# ============================================================================
# JSON VALIDATION AND REPAIR
# ============================================================================

validate_and_fix_json_menu() {
    show_header
    echo -e "${WHITE}Validate & Fix JSON Configuration:${NC}"
    echo ""
    
    local files=("$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG")
    local has_errors=false
    
    for file in "${files[@]}"; do
        echo -e "${BLUE}Checking $(basename $file)...${NC}"
        if [[ -f "$file" ]]; then
            if ! validate_json "$file"; then
                has_errors=true
                echo ""
            fi
        else
            echo -e "${YELLOW}  File not found${NC}"
            echo ""
        fi
    done
    
    if $has_errors; then
        echo ""
        echo -e "${YELLOW}JSON errors detected!${NC}"
        echo -e "${WHITE}Options:${NC}"
        echo -e "${GREEN}1.${NC} Attempt automatic fix"
        echo -e "${GREEN}2.${NC} View detailed errors"
        echo -e "${GREEN}3.${NC} Restore from backup"
        echo -e "${GREEN}4.${NC} Manual edit with vi"
        echo ""
        echo -n -e "${YELLOW}Select option [1-4]: ${NC}"
        read fix_choice
        
        case $fix_choice in
            1) attempt_json_fix ;;
            2) view_json_errors ;;
            3) restore_from_backup ;;
            4) manual_edit_json ;;
        esac
    else
        echo -e "${GREEN}All JSON files are valid!${NC}"
    fi
    
    pause_for_user
}

attempt_json_fix() {
    echo ""
    echo -e "${BLUE}Attempting to fix JSON errors...${NC}"
    
    # Specific fix for known issue with travelers.com
    if [[ -f "$BEC_CONFIG" ]]; then
        temp_file=$(mktemp)
        
        # Try to fix the travelers.com trust_level issue
        $PYTHON -c "
import json
import sys

try:
    with open('$BEC_CONFIG', 'r') as f:
        content = f.read()
    
    # Fix known issue with trust_level in require_auth array
    import re
    # This regex finds trust_level incorrectly placed in require_auth arrays
    pattern = r'\"require_auth\":\s*\[[^]]*\"trust_level\":\s*\d+[^]]*\]'
    if re.search(pattern, content):
        print('Found trust_level in require_auth array - fixing...')
        # Load and fix the JSON
        data = json.loads(content)
        
        # Fix whitelisted_domains
        if 'whitelisted_domains' in data and 'authentication_aware' in data['whitelisted_domains']:
            for domain, config in data['whitelisted_domains']['authentication_aware'].items():
                if 'require_auth' in config and isinstance(config['require_auth'], list):
                    # Remove any non-string items from require_auth
                    config['require_auth'] = [item for item in config['require_auth'] if isinstance(item, str)]
        
        with open('$temp_file', 'w') as f:
            json.dump(data, f, indent=2)
        print('Fixed and saved')
        sys.exit(0)
    else:
        # Just validate and pretty-print
        data = json.loads(content)
        with open('$temp_file', 'w') as f:
            json.dump(data, f, indent=2)
        sys.exit(0)
        
except json.JSONDecodeError as e:
    print(f'JSON decode error: {e}')
    sys.exit(1)
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
" 2>&1
        
        if [[ $? -eq 0 ]]; then
            create_backup "$BEC_CONFIG" "Before automatic fix"
            mv "$temp_file" "$BEC_CONFIG"
            echo -e "${GREEN}✓ Successfully fixed JSON errors${NC}"
        else
            echo -e "${RED}✗ Could not automatically fix JSON${NC}"
            rm -f "$temp_file"
        fi
    fi
}

view_json_errors() {
    echo ""
    local files=("$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG")
    
    for file in "${files[@]}"; do
        if [[ -f "$file" ]]; then
            echo -e "${BLUE}Errors in $(basename $file):${NC}"
            jq '.' "$file" 2>&1 | grep -E "parse error|Expected|Invalid" | head -10
            echo ""
        fi
    done
}

manual_edit_json() {
    echo ""
    echo -e "${WHITE}Select file to edit:${NC}"
    echo -e "${GREEN}1.${NC} bec_config.json"
    echo -e "${GREEN}2.${NC} module_config.json"
    echo -e "${GREEN}3.${NC} email_filter_config.json"
    echo -e "${GREEN}4.${NC} authentication_config.json"
    echo -e "${GREEN}5.${NC} threshold_config.json"
    echo ""
    echo -n -e "${YELLOW}Select file [1-5]: ${NC}"
    read file_choice
    
    case $file_choice in
        1) file_to_edit="$BEC_CONFIG" ;;
        2) file_to_edit="$MODULE_CONFIG" ;;
        3) file_to_edit="$FILTER_CONFIG" ;;
        4) file_to_edit="$AUTH_CONFIG" ;;
        5) file_to_edit="$THRESHOLD_CONFIG" ;;
        *) echo -e "${RED}Invalid choice${NC}"; return ;;
    esac
    
    if [[ -f "$file_to_edit" ]]; then
        create_backup "$file_to_edit" "Before manual edit"
        vi "$file_to_edit"
        echo ""
        echo -e "${BLUE}Validating edited file...${NC}"
        validate_json "$file_to_edit"
    fi
}

check_permissions_menu() {
    show_header
    echo -e "${WHITE}Check File Permissions:${NC}"
    echo ""
    
    local files=("$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG")
    local needs_fix=false
    
    for file in "${files[@]}"; do
        if ! check_permissions "$file"; then
            needs_fix=true
        fi
        echo ""
    done
    
    if $needs_fix; then
        echo -n -e "${YELLOW}Fix permissions? [y/N]: ${NC}"
        read fix_perms
        if [[ "$fix_perms" =~ ^[Yy]$ ]]; then
            for file in "${files[@]}"; do
                fix_permissions "$file"
            done
        fi
    else
        echo -e "${GREEN}All permissions are correct!${NC}"
    fi
    
    pause_for_user
}

# ============================================================================
# BEC DOMAIN WHITELIST WITH TRUST LEVELS
# ============================================================================

bec_domain_menu() {
    while true; do
        show_header
        echo -e "${WHITE}BEC Domain Whitelist Management (with Trust Levels):${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} Add Domain to Whitelist (with Trust Level)"
        echo -e "${GREEN}2.${NC} View All Whitelisted Domains"
        echo -e "${GREEN}3.${NC} Search/Filter Whitelisted Domains"
        echo -e "${GREEN}4.${NC} Remove Domain from Whitelist"
        echo -e "${GREEN}5.${NC} Modify Domain Trust Level"
        echo -e "${GREEN}6.${NC} View Trust Level Guide"
        echo -e "${GREEN}7.${NC} Add Bulk Sender Exception"
        echo -e "${GREEN}8.${NC} View Bulk Sender Exceptions"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-8,9]: ${NC}"

        read choice
        case $choice in
            1) add_bec_domain_whitelist ;;
            2) view_bec_domain_whitelist ;;
            3) search_bec_domain_whitelist ;;
            4) remove_bec_domain_whitelist ;;
            5) modify_domain_trust_level ;;
            6) view_trust_level_guide ;;
            7) add_bulk_sender_exception ;;
            8) view_bulk_sender_exceptions ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

add_bec_domain_whitelist() {
    show_header
    echo -e "${WHITE}Add Domain to BEC Whitelist with Trust Level:${NC}"
    echo ""
    
    # First, validate the JSON
    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        echo -e "${YELLOW}Please fix JSON errors first (Main Menu option 11)${NC}"
        pause_for_user
        return
    fi
    
    # Ensure whitelisted_domains section exists
    if ! jq -e '.whitelisted_domains.authentication_aware' "$BEC_CONFIG" >/dev/null 2>&1; then
        echo -e "${BLUE}Creating whitelisted_domains section...${NC}"
        temp_file=$(mktemp)
        
        # More robust creation of the section
        jq '. + {"whitelisted_domains": (.whitelisted_domains // {})} | 
           .whitelisted_domains + {"authentication_aware": (.whitelisted_domains.authentication_aware // {})}' \
           "$BEC_CONFIG" > "$temp_file" 2>/dev/null
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_file" "$BEC_CONFIG"
            echo -e "${GREEN}✓ Created whitelisted_domains section${NC}"
        else
            echo -e "${RED}✗ Failed to create section${NC}"
            echo -e "${YELLOW}Attempting alternative method...${NC}"
            
            # Alternative method using Python
            $PYTHON -c "
import json
with open('$BEC_CONFIG', 'r') as f:
    data = json.load(f)
if 'whitelisted_domains' not in data:
    data['whitelisted_domains'] = {}
if 'authentication_aware' not in data['whitelisted_domains']:
    data['whitelisted_domains']['authentication_aware'] = {}
with open('$temp_file', 'w') as f:
    json.dump(data, f, indent=2)
" 2>/dev/null
            
            if [[ $? -eq 0 ]]; then
                mv "$temp_file" "$BEC_CONFIG"
                echo -e "${GREEN}✓ Created section using alternative method${NC}"
            else
                echo -e "${RED}✗ Could not create section. Check JSON syntax.${NC}"
                rm -f "$temp_file"
                pause_for_user
                return
            fi
        fi
    fi

    echo -n -e "${YELLOW}Enter domain (e.g., example.com): ${NC}"
    read domain

    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi

    # Clean domain
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | tr '[:upper:]' '[:lower:]')

    # Check if domain already exists
    if jq -e ".whitelisted_domains.authentication_aware[\"$domain\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
        echo -e "${RED}Domain $domain already exists in whitelist.${NC}"
        pause_for_user
        return
    fi

    echo -n -e "${YELLOW}Enter description: ${NC}"
    read description

    echo ""
    echo -e "${WHITE}Authentication Requirements:${NC}"
    echo -e "${GREEN}1.${NC} Standard (SPF + DKIM)"
    echo -e "${GREEN}2.${NC} High security (SPF + DKIM + DMARC)"
    echo -e "${GREEN}3.${NC} DKIM only (for forwarded emails)"
    echo -e "${GREEN}4.${NC} SPF only"
    echo -e "${GREEN}5.${NC} Internal domain validation"
    echo ""
    echo -n -e "${YELLOW}Select [1-5]: ${NC}"
    read auth_choice

    case $auth_choice in
        1) auth_req='["spf", "dkim"]' ;;
        2) auth_req='["spf", "dkim", "dmarc"]' ;;
        3) auth_req='["dkim"]' ;;
        4) auth_req='["spf"]' ;;
        5) auth_req='["internal_domain"]' ;;
        *)
            echo -e "${RED}Invalid choice. Using SPF + DKIM.${NC}"
            auth_req='["spf", "dkim"]'
            ;;
    esac

    echo ""
    view_trust_level_guide_inline

    echo -n -e "${YELLOW}Enter trust level [0-5, default 0]: ${NC}"
    read trust_level
    
    if [[ ! "$trust_level" =~ ^[0-5]$ ]]; then
        trust_level="0"
        echo -e "${BLUE}Using default trust level: 0${NC}"
    fi

    echo ""
    echo -n -e "${YELLOW}Bypass financial keyword checks? [y/N]: ${NC}"
    read bypass_financial

    if [[ "$bypass_financial" =~ ^[Yy]$ ]]; then
        bypass_python="True"
        bypass_display="Yes"
    else
        bypass_python="False"
        bypass_display="No"
    fi

    echo ""
    echo -e "${BLUE}Summary:${NC}"
    echo -e "  Domain: ${WHITE}$domain${NC}"
    echo -e "  Description: ${WHITE}$description${NC}"
    echo -e "  Authentication: ${WHITE}$(echo $auth_req | tr -d '[]"' | tr ',' ' ')${NC}"
    echo -e "  Trust Level: ${WHITE}$trust_level${NC}"
    echo -e "  Bypass Financial: ${WHITE}$bypass_display${NC}"
    echo ""
    echo -n -e "${YELLOW}Add this domain? [y/N]: ${NC}"
    read confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi

    create_backup "$BEC_CONFIG" "Before adding domain $domain with trust level $trust_level"

    temp_file=$(mktemp)

    # Escape single quotes in string variables for Python
    description_escaped="${description//\'/\\\'}"
    domain_escaped="${domain//\'/\\\'}"

    # Use Python for more reliable JSON manipulation
    $PYTHON -c "
import json
import sys

try:
    with open('$BEC_CONFIG', 'r') as f:
        data = json.load(f)

    # Ensure structure exists
    if 'whitelisted_domains' not in data:
        data['whitelisted_domains'] = {}
    if 'authentication_aware' not in data['whitelisted_domains']:
        data['whitelisted_domains']['authentication_aware'] = {}

    # Add the new domain
    data['whitelisted_domains']['authentication_aware']['$domain_escaped'] = {
        'require_auth': $auth_req,
        'trust_level': $trust_level,
        'description': '$description_escaped',
        'bypass_financial_checks': $bypass_python
    }
    
    with open('$temp_file', 'w') as f:
        json.dump(data, f, indent=2)
    
    print('Success')
    sys.exit(0)
    
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
" 2>&1

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully added $domain to domain whitelist"
        echo -e "${BLUE}  Trust Level: $trust_level${NC}"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

view_bec_domain_whitelist() {
    show_header
    echo -e "${WHITE}Current BEC Domain Whitelist:${NC}"
    echo ""

    if [[ -f "$BEC_CONFIG" ]]; then
        if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
            echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
            pause_for_user
            return
        fi
        
        if jq -e '.whitelisted_domains.authentication_aware' "$BEC_CONFIG" >/dev/null 2>&1; then
            domain_count=$(jq -r '.whitelisted_domains.authentication_aware | length' "$BEC_CONFIG" 2>/dev/null)
            
            if [[ "$domain_count" == "0" ]]; then
                echo -e "${YELLOW}No domains configured in authentication-aware whitelist.${NC}"
            else
                echo -e "${GREEN}Authentication-Aware Domain Whitelist ($domain_count domains):${NC}"
                echo ""
                
                # Enhanced display with trust level color coding
                jq -r '.whitelisted_domains.authentication_aware | to_entries[] | 
                    "\(.key)|\(.value.trust_level // 0)|\(.value.description)|\(.value.require_auth | join(", "))|\(.value.bypass_financial_checks)"' \
                    "$BEC_CONFIG" 2>/dev/null | while IFS='|' read -r domain trust desc auth bypass; do
                    
                    # Color code by trust level
                    case $trust in
                        0) trust_color="${WHITE}" ;;
                        1) trust_color="${CYAN}" ;;
                        2) trust_color="${BLUE}" ;;
                        3) trust_color="${GREEN}" ;;
                        4) trust_color="${YELLOW}" ;;
                        5) trust_color="${RED}" ;;
                        *) trust_color="${WHITE}" ;;
                    esac
                    
                    echo -e "${WHITE}Domain: ${NC}$domain"
                    echo -e "  ${BLUE}Description:${NC} $desc"
                    echo -e "  ${BLUE}Auth Required:${NC} $auth"
                    echo -e "  ${BLUE}Trust Level:${NC} ${trust_color}$trust${NC} $(get_trust_description $trust)"
                    echo -e "  ${BLUE}Bypass Financial:${NC} $bypass"
                    echo ""
                done
            fi
        else
            echo -e "${YELLOW}No authentication_aware section found.${NC}"
        fi
        
        # Also show trusted_no_auth domains if they exist
        if jq -e '.whitelisted_domains.trusted_no_auth.domains' "$BEC_CONFIG" >/dev/null 2>&1; then
            no_auth_count=$(jq -r '.whitelisted_domains.trusted_no_auth.domains | length' "$BEC_CONFIG" 2>/dev/null)
            if [[ "$no_auth_count" -gt "0" ]]; then
                echo -e "${YELLOW}No-Auth Domains (Trust Level 5 - Use with caution):${NC}"
                jq -r '.whitelisted_domains.trusted_no_auth.domains[]' "$BEC_CONFIG" 2>/dev/null | while read -r domain; do
                    echo -e "  ${RED}• $domain${NC}"
                done
                echo ""
            fi
        fi
    else
        echo -e "${RED}BEC configuration file not found: $BEC_CONFIG${NC}"
    fi

    pause_for_user
}

remove_bec_domain_whitelist() {
    show_header
    echo -e "${WHITE}Remove Domain from BEC Whitelist:${NC}"
    echo ""

    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        pause_for_user
        return
    fi

    mapfile -t domain_list < <(jq -r '.whitelisted_domains.authentication_aware | keys[]' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#domain_list[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No domains in whitelist.${NC}"
        pause_for_user
        return
    fi

    echo -e "${GREEN}Current whitelisted domains:${NC}"
    for i in "${!domain_list[@]}"; do
        domain="${domain_list[$i]}"
        trust_level=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].trust_level // 0" "$BEC_CONFIG" 2>/dev/null)
        description=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].description" "$BEC_CONFIG" 2>/dev/null)
        printf "%2d) %-30s (Trust: %s) - %s\n" $((i+1)) "$domain" "$trust_level" "$description"
    done
    echo ""

    echo -n -e "${YELLOW}Enter domain number or name to remove: ${NC}"
    read selection

    if [[ -z "$selection" ]]; then
        echo -e "${RED}Selection cannot be empty.${NC}"
        pause_for_user
        return
    fi

    if [[ "$selection" =~ ^[0-9]+$ ]]; then
        if [[ "$selection" -lt 1 || "$selection" -gt ${#domain_list[@]} ]]; then
            echo -e "${RED}Invalid number.${NC}"
            pause_for_user
            return
        fi
        domain="${domain_list[$((selection-1))]}"
    else
        domain="$selection"
        if ! jq -e ".whitelisted_domains.authentication_aware[\"$domain\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
            echo -e "${RED}Domain $domain not found.${NC}"
            pause_for_user
            return
        fi
    fi

    echo ""
    echo -n -e "${YELLOW}Remove $domain? [y/N]: ${NC}"
    read confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi

    create_backup "$BEC_CONFIG" "Before removing domain $domain"

    temp_file=$(mktemp)
    jq --arg domain "$domain" \
       'del(.whitelisted_domains.authentication_aware[$domain])' "$BEC_CONFIG" > "$temp_file"

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully removed $domain"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

modify_domain_trust_level() {
    show_header
    echo -e "${WHITE}Modify Domain Trust Level:${NC}"
    echo ""

    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        pause_for_user
        return
    fi

    mapfile -t domain_list < <(jq -r '.whitelisted_domains.authentication_aware | keys[]' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#domain_list[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No domains in whitelist.${NC}"
        pause_for_user
        return
    fi

    echo -e "${GREEN}Current whitelisted domains:${NC}"
    for i in "${!domain_list[@]}"; do
        domain="${domain_list[$i]}"
        trust_level=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].trust_level // 0" "$BEC_CONFIG" 2>/dev/null)
        description=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].description" "$BEC_CONFIG" 2>/dev/null)
        printf "%2d) %-30s (Current Trust: %s) - %s\n" $((i+1)) "$domain" "$trust_level" "$description"
    done
    echo ""

    echo -n -e "${YELLOW}Enter domain number or name to modify: ${NC}"
    read selection

    if [[ -z "$selection" ]]; then
        echo -e "${RED}Selection cannot be empty.${NC}"
        pause_for_user
        return
    fi

    if [[ "$selection" =~ ^[0-9]+$ ]]; then
        if [[ "$selection" -lt 1 || "$selection" -gt ${#domain_list[@]} ]]; then
            echo -e "${RED}Invalid number.${NC}"
            pause_for_user
            return
        fi
        domain="${domain_list[$((selection-1))]}"
    else
        domain="$selection"
        if ! jq -e ".whitelisted_domains.authentication_aware[\"$domain\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
            echo -e "${RED}Domain $domain not found.${NC}"
            pause_for_user
            return
        fi
    fi

    current_trust=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].trust_level // 0" "$BEC_CONFIG" 2>/dev/null)
    
    echo ""
    echo -e "${BLUE}Current trust level for $domain: $current_trust${NC}"
    echo ""
    view_trust_level_guide_inline
    echo -n -e "${YELLOW}Enter new trust level [0-5]: ${NC}"
    read new_trust

    if [[ ! "$new_trust" =~ ^[0-5]$ ]]; then
        echo -e "${RED}Invalid trust level. Must be 0-5.${NC}"
        pause_for_user
        return
    fi

    if [[ "$new_trust" == "$current_trust" ]]; then
        echo -e "${YELLOW}Trust level unchanged.${NC}"
        pause_for_user
        return
    fi

    create_backup "$BEC_CONFIG" "Before modifying trust level for $domain"

    temp_file=$(mktemp)
    jq --arg domain "$domain" \
       --arg trust "$new_trust" \
       '.whitelisted_domains.authentication_aware[$domain].trust_level = ($trust | tonumber)' \
       "$BEC_CONFIG" > "$temp_file"

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully updated trust level for $domain"
        echo -e "${BLUE}  Old trust level: $current_trust${NC}"
        echo -e "${BLUE}  New trust level: $new_trust${NC}"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

view_trust_level_guide() {
    show_header
    echo -e "${WHITE}Trust Level Guide:${NC}"
    echo ""
    echo -e "${CYAN}Trust levels control how strict security checks are for whitelisted domains.${NC}"
    echo -e "${CYAN}Higher trust levels reduce security sensitivity but increase risk.${NC}"
    echo ""
    echo -e "${WHITE}Level 0 - Default (Strictest)${NC}"
    echo -e "  • Full BEC detection enabled"
    echo -e "  • All financial checks active"
    echo -e "  • Normal urgency scoring"
    echo -e "  • No threshold adjustments"
    echo -e "  ${GREEN}Use for: Unknown or first-time senders${NC}"
    echo ""
    echo -e "${CYAN}Level 1 - Minimal Trust${NC}"
    echo -e "  • Confidence threshold +0.05"
    echo -e "  • Full financial checks"
    echo -e "  • Normal urgency scoring"
    echo -e "  ${GREEN}Use for: Occasional business contacts${NC}"
    echo ""
    echo -e "${BLUE}Level 2 - Low Trust${NC}"
    echo -e "  • Confidence threshold +0.1"
    echo -e "  • Financial multiplier 0.8x"
    echo -e "  • Urgency multiplier 0.9x"
    echo -e "  ${GREEN}Use for: Regular vendors with some history${NC}"
    echo ""
    echo -e "${GREEN}Level 3 - Medium Trust${NC}"
    echo -e "  • Confidence threshold +0.15"
    echo -e "  • Financial multiplier 0.6x"
    echo -e "  • Urgency multiplier 0.7x"
    echo -e "  • Bypasses financial keyword checks"
    echo -e "  ${GREEN}Use for: Established business partners${NC}"
    echo ""
    echo -e "${YELLOW}Level 4 - High Trust${NC}"
    echo -e "  • Confidence threshold +0.2"
    echo -e "  • Financial multiplier 0.3x"
    echo -e "  • Urgency multiplier 0.5x"
    echo -e "  • Bypasses financial checks"
    echo -e "  ${GREEN}Use for: Long-term trusted partners${NC}"
    echo ""
    echo -e "${RED}Level 5 - Maximum Trust${NC}"
    echo -e "  • Confidence threshold +0.3"
    echo -e "  • Financial multiplier 0.1x"
    echo -e "  • Urgency multiplier 0.3x"
    echo -e "  • Bypasses most detection"
    echo -e "  ${RED}⚠ WARNING: Use sparingly - significantly reduces security${NC}"
    echo -e "  ${GREEN}Use for: Internal systems, critical infrastructure only${NC}"
    echo ""
    pause_for_user
}

view_trust_level_guide_inline() {
    echo -e "${WHITE}Trust Level Configuration:${NC}"
    echo -e "${GREEN}0${NC} = Default (strictest) - Unknown senders"
    echo -e "${CYAN}1${NC} = Minimal trust - Occasional contacts"
    echo -e "${BLUE}2${NC} = Low trust - Regular vendors"
    echo -e "${GREEN}3${NC} = Medium trust - Business partners"
    echo -e "${YELLOW}4${NC} = High trust - Long-term partners"
    echo -e "${RED}5${NC} = Maximum trust - Internal systems only ${RED}⚠${NC}"
    echo ""
}

get_trust_description() {
    local level=$1
    case $level in
        0) echo "(Default - Strictest)" ;;
        1) echo "(Minimal Trust)" ;;
        2) echo "(Low Trust)" ;;
        3) echo "(Medium Trust)" ;;
        4) echo "(High Trust)" ;;
        5) echo "(Maximum Trust ⚠)" ;;
        *) echo "(Unknown)" ;;
    esac
}

add_bulk_sender_exception() {
    show_header
    echo -e "${WHITE}Add Bulk Sender Exception:${NC}"
    echo ""
    echo -e "${BLUE}Bulk sender exceptions are for legitimate mass mailers.${NC}"
    echo ""

    echo -n -e "${YELLOW}Enter domain (e.g., mailchimp.com): ${NC}"
    read domain

    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi

    echo -n -e "${YELLOW}Enter description: ${NC}"
    read description

    echo -n -e "${YELLOW}Enter trust level [0-5, default 3]: ${NC}"
    read trust_level
    if [[ ! "$trust_level" =~ ^[0-5]$ ]]; then
        trust_level="3"
    fi

    echo -n -e "${YELLOW}Enter sender email pattern (optional): ${NC}"
    read sender_pattern

    echo -n -e "${YELLOW}Enter subject pattern (optional): ${NC}"
    read subject_pattern

    echo -n -e "${YELLOW}Enter content pattern (optional): ${NC}"
    read content_pattern

    create_backup "$BEC_CONFIG" "Before adding bulk sender exception $domain"

    temp_file=$(mktemp)
    
    # Build the patterns arrays
    sender_patterns="[]"
    if [[ -n "$sender_pattern" ]]; then
        sender_patterns="[\"$sender_pattern\"]"
    fi
    
    subject_patterns="[]"
    if [[ -n "$subject_pattern" ]]; then
        subject_patterns="[\"$subject_pattern\"]"
    fi
    
    content_patterns="[]"
    if [[ -n "$content_pattern" ]]; then
        content_patterns="[\"$content_pattern\"]"
    fi

    # Escape single quotes in string variables for Python
    description_escaped="${description//\'/\\\'}"
    domain_escaped="${domain//\'/\\\'}"

    $PYTHON -c "
import json
import sys

try:
    with open('$BEC_CONFIG', 'r') as f:
        data = json.load(f)

    # Ensure structure exists
    if 'whitelist' not in data:
        data['whitelist'] = {}
    if 'bulk_sender_exceptions' not in data['whitelist']:
        data['whitelist']['bulk_sender_exceptions'] = {}
    if 'senders' not in data['whitelist']['bulk_sender_exceptions']:
        data['whitelist']['bulk_sender_exceptions']['senders'] = {}

    # Add the bulk sender
    data['whitelist']['bulk_sender_exceptions']['senders']['$domain_escaped'] = {
        'sender_patterns': $sender_patterns,
        'subject_patterns': $subject_patterns,
        'content_patterns': $content_patterns,
        'require_auth': ['dkim'],
        'bypass_financial_checks': False,
        'trust_score_bonus': $trust_level,
        'description': '$description_escaped'
    }
    
    with open('$temp_file', 'w') as f:
        json.dump(data, f, indent=2)
    
    print('Success')
    sys.exit(0)
    
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
" 2>&1

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully added bulk sender exception for $domain"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

view_bulk_sender_exceptions() {
    show_header
    echo -e "${WHITE}Current Bulk Sender Exceptions:${NC}"
    echo ""

    if [[ -f "$BEC_CONFIG" ]]; then
        if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
            echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
            pause_for_user
            return
        fi
        
        echo -e "${GREEN}Bulk Sender Exceptions:${NC}"
        echo ""

        jq -r '.whitelist.bulk_sender_exceptions.senders | to_entries[] |
               "Domain: \(.key)\n  Description: \(.value.description)\n  Trust Bonus: \(.value.trust_score_bonus // 0)\n  Sender Patterns: \(.value.sender_patterns | join(", "))\n  Subject Patterns: \(.value.subject_patterns | join(", "))\n  Content Patterns: \(.value.content_patterns | join(", "))\n"' \
               "$BEC_CONFIG" 2>/dev/null || echo "No bulk sender exceptions configured"
    else
        echo -e "${RED}BEC configuration file not found: $BEC_CONFIG${NC}"
    fi

    pause_for_user
}

# ============================================================================
# BEC SENDER WHITELIST MANAGEMENT
# ============================================================================

bec_sender_menu() {
    while true; do
        show_header
        echo -e "${WHITE}BEC Sender Whitelist Management:${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} Add Sender to Whitelist"
        echo -e "${GREEN}2.${NC} View All Whitelisted Senders"
        echo -e "${GREEN}3.${NC} Search/Filter Whitelisted Senders"
        echo -e "${GREEN}4.${NC} Remove Sender from Whitelist"
        echo -e "${GREEN}5.${NC} Test Sender Authentication"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-5,9]: ${NC}"

        read choice
        case $choice in
            1) add_bec_sender_whitelist ;;
            2) view_bec_sender_whitelist ;;
            3) search_bec_sender_whitelist ;;
            4) remove_bec_sender_whitelist ;;
            5) test_sender_auth ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

add_bec_sender_whitelist() {
    show_header
    echo -e "${WHITE}Add Sender to BEC Whitelist:${NC}"
    echo ""

    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        pause_for_user
        return
    fi

    echo -n -e "${YELLOW}Enter sender email: ${NC}"
    read sender_email

    if [[ -z "$sender_email" ]]; then
        echo -e "${RED}Email cannot be empty.${NC}"
        pause_for_user
        return
    fi

    # Show which domains have received emails from this sender
    echo ""
    echo -e "${BLUE}Checking email history for ${sender_email}...${NC}"
    recipient_domains=$(mysql --defaults-file=/opt/spacyserver/config/.my.cnf -e "
        SELECT
            SUBSTRING_INDEX(recipients, '@', -1) as domain,
            COUNT(*) as email_count,
            MAX(timestamp) as last_email
        FROM email_analysis
        WHERE LOWER(sender) = LOWER('$sender_email')
            AND recipients LIKE '%@%'
        GROUP BY domain
        ORDER BY email_count DESC
        LIMIT 10;" 2>/dev/null | tail -n +2)

    if [[ -n "$recipient_domains" ]]; then
        echo -e "${GREEN}This sender has sent emails to:${NC}"
        echo "$recipient_domains" | while IFS=$'\t' read -r domain count last_email; do
            echo -e "  ${WHITE}$domain${NC} - $count emails (last: $last_email)"
        done
        echo ""
    else
        echo -e "${YELLOW}No email history found for this sender${NC}"
        echo ""
    fi

    echo -n -e "${YELLOW}Enter description: ${NC}"
    read description

    echo ""
    echo -e "${WHITE}Authentication Requirements:${NC}"
    echo -e "${GREEN}1.${NC} External sender (requires SPF + DKIM)"
    echo -e "${GREEN}2.${NC} High security (requires SPF + DKIM + DMARC)"
    echo -e "${GREEN}3.${NC} DKIM only (for forwarded emails)"
    echo -e "${GREEN}4.${NC} Internal domain (uses internal validation)"
    echo ""
    echo -n -e "${YELLOW}Select [1-4]: ${NC}"
    read auth_choice

    case $auth_choice in
        1) auth_req='["spf", "dkim"]' ;;
        2) auth_req='["spf", "dkim", "dmarc"]' ;;
        3) auth_req='["dkim"]' ;;
        4) auth_req='["internal_domain"]' ;;
        *)
            echo -e "${RED}Invalid choice. Using SPF + DKIM.${NC}"
            auth_req='["spf", "dkim"]'
            ;;
    esac

    echo ""
    echo -e "${WHITE}Domain Association:${NC}"
    echo -e "${YELLOW}Which client domain is this whitelist for?${NC}"
    echo -e "${BLUE}(The sender will only appear in whitelist for users of this domain)${NC}"
    echo ""

    # Get list of client domains from database
    client_domains=$(mysql --defaults-file=/opt/spacyserver/config/.my.cnf -e "SELECT DISTINCT SUBSTRING_INDEX(recipients, '@', -1) as domain FROM email_analysis WHERE recipients LIKE '%@%' ORDER BY domain LIMIT 20;" 2>/dev/null | tail -n +2)

    if [[ -n "$client_domains" ]]; then
        echo -e "${GREEN}Recent client domains:${NC}"
        echo "$client_domains" | nl -s ') '
        echo ""
    fi

    echo -n -e "${YELLOW}Enter domain this whitelist is for (e.g., safesoundins.com): ${NC}"
    read for_domain

    if [[ -z "$for_domain" ]]; then
        echo -e "${RED}Domain association is required for proper filtering.${NC}"
        pause_for_user
        return
    fi

    echo ""
    echo -n -e "${YELLOW}Bypass financial keyword checks? [y/N]: ${NC}"
    read bypass_financial

    if [[ "$bypass_financial" =~ ^[Yy]$ ]]; then
        bypass_python="True"
        bypass_display="Yes"
    else
        bypass_python="False"
        bypass_display="No"
    fi

    echo ""
    view_trust_level_guide_inline

    echo -n -e "${YELLOW}Trust score bonus (0-5, default 0): ${NC}"
    read trust_bonus
    if [[ ! "$trust_bonus" =~ ^[0-5]$ ]]; then
        trust_bonus="0"
    fi

    echo ""
    echo -e "${BLUE}Summary:${NC}"
    echo -e "  Sender: ${WHITE}$sender_email${NC}"
    echo -e "  For Domain: ${WHITE}$for_domain${NC}"
    echo -e "  Description: ${WHITE}$description${NC}"
    echo -e "  Authentication: ${WHITE}$(echo $auth_req | tr -d '[]"' | tr ',' ' ')${NC}"
    echo -e "  Trust Score Bonus: ${WHITE}$trust_bonus${NC}"
    echo -e "  Bypass Financial: ${WHITE}$bypass_display${NC}"
    echo ""
    echo -n -e "${YELLOW}Add this sender? [y/N]: ${NC}"
    read confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi
    
    echo ""
    echo -e "${BLUE}Creating backup before modification...${NC}"
    create_backup "$BEC_CONFIG" "Before adding sender $sender_email"

    temp_file=$(mktemp)

    # Escape single quotes in string variables for Python
    description_escaped="${description//\'/\\\'}"
    sender_email_escaped="${sender_email//\'/\\\'}"
    for_domain_escaped="${for_domain//\'/\\\'}"

    $PYTHON -c "
import json
import sys

try:
    with open('$BEC_CONFIG', 'r') as f:
        data = json.load(f)

    # Ensure structure exists
    if 'whitelist' not in data:
        data['whitelist'] = {}
    if 'authentication_aware' not in data['whitelist']:
        data['whitelist']['authentication_aware'] = {}
    if 'senders' not in data['whitelist']['authentication_aware']:
        data['whitelist']['authentication_aware']['senders'] = {}

    # Add the sender
    sender_obj = {
        'require_auth': $auth_req,
        'description': '$description_escaped',
        'bypass_financial_checks': $bypass_python,
        'for_domain': '$for_domain_escaped'
    }

    if $trust_bonus > 0:
        sender_obj['trust_score_bonus'] = $trust_bonus

    data['whitelist']['authentication_aware']['senders']['$sender_email_escaped'] = sender_obj
    
    with open('$temp_file', 'w') as f:
        json.dump(data, f, indent=2)
    
    print('Success')
    sys.exit(0)
    
except Exception as e:
    print(f'Error: {e}')
    sys.exit(1)
" 2>&1

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully added $sender_email to whitelist"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

view_bec_sender_whitelist() {
    show_header
    echo -e "${WHITE}Current BEC Sender Whitelist:${NC}"
    echo ""

    if [[ -f "$BEC_CONFIG" ]]; then
        if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
            echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
            pause_for_user
            return
        fi
        
        echo -e "${GREEN}Authentication-Aware Sender Whitelist:${NC}"
        echo ""

        jq -r '.whitelist.authentication_aware.senders | to_entries[] |
               "Email: \(.key)\n  For Domain: \(.value.for_domain // "Not specified")\n  Description: \(.value.description)\n  Auth Required: \(.value.require_auth | join(", "))\n  Bypass Financial: \(.value.bypass_financial_checks)\n  Trust Bonus: \(.value.trust_score_bonus // 0)\n"' \
               "$BEC_CONFIG" 2>/dev/null || echo "Unable to parse sender whitelist"
    else
        echo -e "${RED}BEC configuration file not found: $BEC_CONFIG${NC}"
    fi

    pause_for_user
}

remove_bec_sender_whitelist() {
    show_header
    echo -e "${WHITE}Remove Sender from BEC Whitelist:${NC}"
    echo ""

    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        pause_for_user
        return
    fi

    mapfile -t sender_list < <(jq -r '.whitelist.authentication_aware.senders | keys[]' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#sender_list[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No senders in whitelist.${NC}"
        pause_for_user
        return
    fi

    echo -e "${GREEN}Current whitelisted senders:${NC}"
    for i in "${!sender_list[@]}"; do
        sender="${sender_list[$i]}"
        description=$(jq -r ".whitelist.authentication_aware.senders[\"$sender\"].description" "$BEC_CONFIG" 2>/dev/null)
        printf "%2d) %s\n" $((i+1)) "$sender"
        printf "    %s\n" "$description"
    done
    echo ""

    echo -n -e "${YELLOW}Enter sender number or email to remove: ${NC}"
    read selection

    if [[ -z "$selection" ]]; then
        echo -e "${RED}Selection cannot be empty.${NC}"
        pause_for_user
        return
    fi

    if [[ "$selection" =~ ^[0-9]+$ ]]; then
        if [[ "$selection" -lt 1 || "$selection" -gt ${#sender_list[@]} ]]; then
            echo -e "${RED}Invalid number.${NC}"
            pause_for_user
            return
        fi
        sender_email="${sender_list[$((selection-1))]}"
    else
        sender_email="$selection"
        if ! jq -e ".whitelist.authentication_aware.senders[\"$sender_email\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
            echo -e "${RED}Sender $sender_email not found.${NC}"
            pause_for_user
            return
        fi
    fi

    echo ""
    echo -n -e "${YELLOW}Remove $sender_email? [y/N]: ${NC}"
    read confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi

    create_backup "$BEC_CONFIG" "Before removing sender $sender_email"

    temp_file=$(mktemp)
    jq --arg email "$sender_email" \
       'del(.whitelist.authentication_aware.senders[$email])' "$BEC_CONFIG" > "$temp_file"

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully removed $sender_email"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

test_sender_auth() {
    show_header
    echo -e "${WHITE}Test Sender Authentication:${NC}"
    echo ""
    echo -e "${YELLOW}This tests authentication requirements for whitelisted senders.${NC}"
    
    # Show available senders
    echo -e "${GREEN}Whitelisted senders:${NC}"
    jq -r '.whitelist.authentication_aware.senders | keys[]' "$BEC_CONFIG" 2>/dev/null | nl
    
    echo ""
    echo -n -e "${YELLOW}Enter sender email to test: ${NC}"
    read test_sender
    
    if [[ -z "$test_sender" ]]; then
        echo -e "${RED}Sender email required.${NC}"
        pause_for_user
        return
    fi
    
    # Get sender requirements
    if jq -e ".whitelist.authentication_aware.senders[\"$test_sender\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
        auth_req=$(jq -r ".whitelist.authentication_aware.senders[\"$test_sender\"].require_auth[]" "$BEC_CONFIG" 2>/dev/null)
        description=$(jq -r ".whitelist.authentication_aware.senders[\"$test_sender\"].description" "$BEC_CONFIG" 2>/dev/null)
        
        echo ""
        echo -e "${GREEN}Sender Configuration:${NC}"
        echo -e "${BLUE}  Email: $test_sender${NC}"
        echo -e "${BLUE}  Description: $description${NC}"
        echo -e "${BLUE}  Required Auth: $auth_req${NC}"
        
        echo ""
        echo -e "${GREEN}Testing authentication...${NC}"
        
        # Test real authentication if available
        if [[ "$auth_req" =~ "spf" ]]; then
            echo -e "${BLUE}Testing SPF...${NC}"
            # Get server's primary IP for SPF test
            local server_ip=$(hostname -I | awk '{print $1}')
            $PYTHON -c "
import sys
try:
    import spf
    result, explanation = spf.check2('$server_ip', '$test_sender', '$(echo $test_sender | cut -d@ -f2)')
    print(f'  SPF Result: {result}')
    print(f'  Explanation: {explanation}')
except ImportError:
    print('  SPF library not available')
except Exception as e:
    print(f'  Error: {e}')
" 2>/dev/null
        fi
        
        if [[ "$auth_req" =~ "dkim" ]]; then
            echo -e "${BLUE}DKIM validation requires email content${NC}"
        fi
        
        if [[ "$auth_req" =~ "dmarc" ]]; then
            echo -e "${BLUE}Testing DMARC policy...${NC}"
            $PYTHON -c "
import sys
try:
    import dns.resolver
    domain = '$(echo $test_sender | cut -d@ -f2)'
    dmarc_domain = f'_dmarc.{domain}'
    try:
        answers = dns.resolver.resolve(dmarc_domain, 'TXT')
        for answer in answers:
            txt_record = str(answer).strip('\"')
            if txt_record.startswith('v=DMARC1'):
                print(f'  DMARC Record: {txt_record}')
                break
    except dns.resolver.NXDOMAIN:
        print(f'  No DMARC record found for {domain}')
except ImportError:
    print('  DNS library not available')
" 2>/dev/null
        fi
    else
        echo -e "${RED}Sender $test_sender not found in whitelist.${NC}"
    fi
    
    pause_for_user
}

# ============================================================================
# OTHER MENUS (Simplified versions - can be expanded as needed)
# ============================================================================

executive_protection_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Executive Protection Management:${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} View Protected Executives"
        echo -e "${GREEN}2.${NC} Add Executive Protection"
        echo -e "${GREEN}3.${NC} Remove Executive Protection"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-3,9]: ${NC}"

        read choice
        case $choice in
            1) view_executives ;;
            2) add_executive ;;
            3) remove_executive ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

view_executives() {
    show_header
    echo -e "${WHITE}Protected Executives:${NC}"
    echo ""

    if [[ -f "$BEC_CONFIG" ]]; then
        if jq -e '.executives' "$BEC_CONFIG" >/dev/null 2>&1; then
            exec_count=$(jq -r '.executives | length' "$BEC_CONFIG" 2>/dev/null)
            if [[ "$exec_count" == "0" ]]; then
                echo -e "${YELLOW}No executives configured for protection.${NC}"
            else
                echo -e "${GREEN}Protected Executives ($exec_count total):${NC}"
                echo ""
                jq -r '.executives | to_entries[] |
                       "Email: \(.key)\n  Name: \(.value.name)\n  Title: \(.value.title)\n"' \
                       "$BEC_CONFIG" 2>/dev/null
            fi
        else
            echo -e "${YELLOW}No executives section found.${NC}"
        fi
    else
        echo -e "${RED}BEC configuration file not found.${NC}"
    fi

    pause_for_user
}

add_executive() {
    show_header
    echo -e "${WHITE}Add Executive Protection:${NC}"
    echo ""

    echo -n -e "${YELLOW}Enter executive email: ${NC}"
    read exec_email

    if [[ -z "$exec_email" ]]; then
        echo -e "${RED}Email cannot be empty.${NC}"
        pause_for_user
        return
    fi

    echo -n -e "${YELLOW}Enter executive name: ${NC}"
    read exec_name

    echo -n -e "${YELLOW}Enter executive title: ${NC}"
    read exec_title

    create_backup "$BEC_CONFIG" "Before adding executive $exec_email"

    temp_file=$(mktemp)
    exec_object=$(jq -n \
        --arg name "$exec_name" \
        --arg title "$exec_title" \
        '{
            "name": $name,
            "title": $title,
            "aliases": [],
            "typical_hours": {"start": 8, "end": 19},
            "timezone": "America/New_York",
            "common_topics": [],
            "communication_style": "formal"
        }')

    jq --arg email "$exec_email" \
       --argjson exec_obj "$exec_object" \
       '.executives[$email] = $exec_obj' \
       "$BEC_CONFIG" > "$temp_file" 2>/dev/null

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully added executive $exec_name"
    else
        echo -e "${RED}✗${NC} Failed to update configuration"
        rm -f "$temp_file"
    fi

    pause_for_user
}

remove_executive() {
    show_header
    echo -e "${WHITE}Remove Executive Protection:${NC}"
    echo ""

    if ! jq -e '.executives' "$BEC_CONFIG" >/dev/null 2>&1; then
        echo -e "${RED}No executives configured.${NC}"
        pause_for_user
        return
    fi

    echo -e "${GREEN}Current executives:${NC}"
    jq -r '.executives | to_entries[] | "\(.key) - \(.value.name)"' "$BEC_CONFIG" 2>/dev/null | nl
    echo ""

    echo -n -e "${YELLOW}Enter executive email to remove: ${NC}"
    read exec_email

    if [[ -z "$exec_email" ]]; then
        echo -e "${RED}Email cannot be empty.${NC}"
        pause_for_user
        return
    fi

    echo ""
    echo -n -e "${YELLOW}Remove $exec_email? [y/N]: ${NC}"
    read confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi

    create_backup "$BEC_CONFIG" "Before removing executive $exec_email"

    temp_file=$(mktemp)
    jq --arg email "$exec_email" \
       'del(.executives[$email])' "$BEC_CONFIG" > "$temp_file"

    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓${NC} Successfully removed executive"
    else
        echo -e "${RED}✗${NC} Failed to remove executive"
        rm -f "$temp_file"
    fi

    pause_for_user
}

# ============================================================================
# COMPANY IMPERSONATION PROTECTION
# ============================================================================

company_impersonation_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Company Impersonation Protection:${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} View Current Company Configuration"
        echo -e "${GREEN}2.${NC} Add/Update Company Names"
        echo -e "${GREEN}3.${NC} Manage Protected Departments"
        echo -e "${GREEN}4.${NC} Manage Company Domains"
        echo -e "${GREEN}5.${NC} Configure Scam Pattern Detection"
        echo -e "${GREEN}6.${NC} Test Impersonation Detection"
        echo ""
        echo -e "${RED}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-6,9]: ${NC}"
        
        read choice
        case $choice in
            1) view_company_config ;;
            2) manage_company_names ;;
            3) manage_protected_departments ;;
            4) manage_company_domains ;;
            5) manage_scam_patterns ;;
            6) test_impersonation_detection ;;
            9) return ;;
            *) echo -e "${RED}Invalid option${NC}"; sleep 1 ;;
        esac
    done
}

view_company_config() {
    show_header
    echo -e "${WHITE}Current Company Impersonation Configuration:${NC}"
    echo ""
    
    if ! validate_json "$BEC_CONFIG" 2>/dev/null; then
        echo -e "${RED}✗ BEC configuration has JSON errors!${NC}"
        pause_for_user
        return
    fi
    
    if jq -e '.company_impersonation' "$BEC_CONFIG" >/dev/null 2>&1; then
        echo -e "${BLUE}Company Names:${NC}"
        jq -r '.company_impersonation.company_names[]? // empty' "$BEC_CONFIG" 2>/dev/null | while read -r name; do
            echo -e "  • $name"
        done
        
        echo ""
        echo -e "${BLUE}Protected Departments:${NC}"
        jq -r '.company_impersonation.protected_departments[]? // empty' "$BEC_CONFIG" 2>/dev/null | while read -r dept; do
            echo -e "  • $dept"
        done
        
        echo ""
        echo -e "${BLUE}Company Domains:${NC}"
        jq -r '.company_impersonation.company_domains[]? // empty' "$BEC_CONFIG" 2>/dev/null | while read -r domain; do
            echo -e "  • $domain"
        done
        
        echo ""
        echo -e "${BLUE}Scam Pattern Subjects:${NC}"
        jq -r '.company_impersonation.scam_patterns.subjects[]? // empty' "$BEC_CONFIG" 2>/dev/null | while read -r pattern; do
            echo -e "  • $pattern"
        done
    else
        echo -e "${YELLOW}Company impersonation protection not configured.${NC}"
    fi
    
    pause_for_user
}

manage_company_names() {
    show_header
    echo -e "${WHITE}Manage Company Names:${NC}"
    echo ""
    echo -e "${GREEN}1.${NC} Add company name"
    echo -e "${GREEN}2.${NC} Remove company name"
    echo -e "${GREEN}3.${NC} View current names"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    
    read choice
    case $choice in
        1) add_company_name ;;
        2) remove_company_name ;;
        3) 
            echo ""
            echo -e "${BLUE}Current Company Names:${NC}"
            jq -r '.company_impersonation.company_names[]? // empty' "$BEC_CONFIG" 2>/dev/null | nl
            pause_for_user
            ;;
        *) echo -e "${RED}Invalid option${NC}" ;;
    esac
}

add_company_name() {
    echo ""
    echo -n -e "${YELLOW}Enter company name to add: ${NC}"
    read -r company_name
    
    if [[ -z "$company_name" ]]; then
        echo -e "${RED}Company name cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    create_backup "$BEC_CONFIG" "Before adding company name $company_name"
    
    temp_file=$(mktemp)
    $PYTHON -c "
import json
import sys
with open('$BEC_CONFIG', 'r') as f:
    data = json.load(f)

if 'company_impersonation' not in data:
    data['company_impersonation'] = {
        'company_names': [],
        'protected_departments': [],
        'company_domains': [],
        'scam_patterns': {'subjects': []}
    }

if 'company_names' not in data['company_impersonation']:
    data['company_impersonation']['company_names'] = []

if '$company_name' not in data['company_impersonation']['company_names']:
    data['company_impersonation']['company_names'].append('$company_name')
    
print(json.dumps(data, indent=2))
" > "$temp_file" 2>/dev/null
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓ Added company name: $company_name${NC}"
    else
        echo -e "${RED}✗ Failed to add company name${NC}"
        rm -f "$temp_file"
    fi
    
    pause_for_user
}

remove_company_name() {
    echo ""
    echo -e "${BLUE}Current Company Names:${NC}"
    mapfile -t names < <(jq -r '.company_impersonation.company_names[]? // empty' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#names[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No company names configured${NC}"
        pause_for_user
        return
    fi
    
    for i in "${!names[@]}"; do
        printf "%2d) %s\n" $((i+1)) "${names[$i]}"
    done
    
    echo ""
    echo -n -e "${YELLOW}Select number to remove (0 to cancel): ${NC}"
    read -r selection
    
    if [[ "$selection" == "0" ]]; then
        return
    fi
    
    if [[ "$selection" -gt 0 && "$selection" -le ${#names[@]} ]]; then
        remove_name="${names[$((selection-1))]}"
        
        create_backup "$BEC_CONFIG" "Before removing company name $remove_name"
        
        temp_file=$(mktemp)
        jq --arg name "$remove_name" \
           '.company_impersonation.company_names -= [$name]' "$BEC_CONFIG" > "$temp_file"
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_file" "$BEC_CONFIG"
            fix_permissions "$BEC_CONFIG"
            echo -e "${GREEN}✓ Removed company name: $remove_name${NC}"
        else
            echo -e "${RED}✗ Failed to remove company name${NC}"
            rm -f "$temp_file"
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
    fi
    
    pause_for_user
}

manage_protected_departments() {
    show_header
    echo -e "${WHITE}Manage Protected Departments:${NC}"
    echo ""
    echo -e "${GREEN}1.${NC} Add protected department"
    echo -e "${GREEN}2.${NC} Remove protected department"
    echo -e "${GREEN}3.${NC} View current departments"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    
    read choice
    case $choice in
        1) add_protected_department ;;
        2) remove_protected_department ;;
        3) 
            echo ""
            echo -e "${BLUE}Current Protected Departments:${NC}"
            jq -r '.company_impersonation.protected_departments[]? // empty' "$BEC_CONFIG" 2>/dev/null | nl
            pause_for_user
            ;;
        *) echo -e "${RED}Invalid option${NC}" ;;
    esac
}

add_protected_department() {
    echo ""
    echo -n -e "${YELLOW}Enter department name to protect: ${NC}"
    read -r dept_name
    
    if [[ -z "$dept_name" ]]; then
        echo -e "${RED}Department name cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    create_backup "$BEC_CONFIG" "Before adding protected department $dept_name"
    
    temp_file=$(mktemp)
    jq --arg dept "$dept_name" \
       '.company_impersonation.protected_departments += [$dept] | .company_impersonation.protected_departments |= unique' \
       "$BEC_CONFIG" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓ Added protected department: $dept_name${NC}"
    else
        echo -e "${RED}✗ Failed to add department${NC}"
        rm -f "$temp_file"
    fi
    
    pause_for_user
}

remove_protected_department() {
    echo ""
    echo -e "${BLUE}Current Protected Departments:${NC}"
    mapfile -t depts < <(jq -r '.company_impersonation.protected_departments[]? // empty' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#depts[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No protected departments configured${NC}"
        pause_for_user
        return
    fi
    
    for i in "${!depts[@]}"; do
        printf "%2d) %s\n" $((i+1)) "${depts[$i]}"
    done
    
    echo ""
    echo -n -e "${YELLOW}Select number to remove (0 to cancel): ${NC}"
    read -r selection
    
    if [[ "$selection" == "0" ]]; then
        return
    fi
    
    if [[ "$selection" -gt 0 && "$selection" -le ${#depts[@]} ]]; then
        remove_dept="${depts[$((selection-1))]}"
        
        create_backup "$BEC_CONFIG" "Before removing protected department"
        
        temp_file=$(mktemp)
        jq --arg dept "$remove_dept" \
           '.company_impersonation.protected_departments -= [$dept]' "$BEC_CONFIG" > "$temp_file"
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_file" "$BEC_CONFIG"
            fix_permissions "$BEC_CONFIG"
            echo -e "${GREEN}✓ Removed protected department: $remove_dept${NC}"
        else
            echo -e "${RED}✗ Failed to remove department${NC}"
            rm -f "$temp_file"
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
    fi
    
    pause_for_user
}

manage_company_domains() {
    show_header
    echo -e "${WHITE}Manage Company Domains:${NC}"
    echo ""
    echo -e "${GREEN}1.${NC} Add company domain"
    echo -e "${GREEN}2.${NC} Remove company domain"
    echo -e "${GREEN}3.${NC} View current domains"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    
    read choice
    case $choice in
        1) add_company_domain ;;
        2) remove_company_domain ;;
        3) 
            echo ""
            echo -e "${BLUE}Current Company Domains:${NC}"
            jq -r '.company_impersonation.company_domains[]? // empty' "$BEC_CONFIG" 2>/dev/null | nl
            pause_for_user
            ;;
        *) echo -e "${RED}Invalid option${NC}" ;;
    esac
}

add_company_domain() {
    echo ""
    echo -n -e "${YELLOW}Enter company domain (e.g., example.com): ${NC}"
    read -r domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    create_backup "$BEC_CONFIG" "Before adding company domain $domain"
    
    temp_file=$(mktemp)
    jq --arg domain "$domain" \
       '.company_impersonation.company_domains += [$domain] | .company_impersonation.company_domains |= unique' \
       "$BEC_CONFIG" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓ Added company domain: $domain${NC}"
    else
        echo -e "${RED}✗ Failed to add domain${NC}"
        rm -f "$temp_file"
    fi
    
    pause_for_user
}

remove_company_domain() {
    echo ""
    echo -e "${BLUE}Current Company Domains:${NC}"
    mapfile -t domains < <(jq -r '.company_impersonation.company_domains[]? // empty' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#domains[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No company domains configured${NC}"
        pause_for_user
        return
    fi
    
    for i in "${!domains[@]}"; do
        printf "%2d) %s\n" $((i+1)) "${domains[$i]}"
    done
    
    echo ""
    echo -n -e "${YELLOW}Select number to remove (0 to cancel): ${NC}"
    read -r selection
    
    if [[ "$selection" == "0" ]]; then
        return
    fi
    
    if [[ "$selection" -gt 0 && "$selection" -le ${#domains[@]} ]]; then
        remove_domain="${domains[$((selection-1))]}"
        
        create_backup "$BEC_CONFIG" "Before removing company domain"
        
        temp_file=$(mktemp)
        jq --arg domain "$remove_domain" \
           '.company_impersonation.company_domains -= [$domain]' "$BEC_CONFIG" > "$temp_file"
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_file" "$BEC_CONFIG"
            fix_permissions "$BEC_CONFIG"
            echo -e "${GREEN}✓ Removed company domain: $remove_domain${NC}"
        else
            echo -e "${RED}✗ Failed to remove domain${NC}"
            rm -f "$temp_file"
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
    fi
    
    pause_for_user
}

manage_scam_patterns() {
    show_header
    echo -e "${WHITE}Manage Scam Pattern Detection:${NC}"
    echo ""
    echo -e "${GREEN}1.${NC} Add scam pattern"
    echo -e "${GREEN}2.${NC} Remove scam pattern"
    echo -e "${GREEN}3.${NC} View current patterns"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    
    read choice
    case $choice in
        1) add_scam_pattern ;;
        2) remove_scam_pattern ;;
        3) 
            echo ""
            echo -e "${BLUE}Current Scam Patterns:${NC}"
            jq -r '.company_impersonation.scam_patterns.subjects[]? // empty' "$BEC_CONFIG" 2>/dev/null | nl
            pause_for_user
            ;;
        *) echo -e "${RED}Invalid option${NC}" ;;
    esac
}

add_scam_pattern() {
    echo ""
    echo -n -e "${YELLOW}Enter scam subject pattern to detect: ${NC}"
    read -r pattern
    
    if [[ -z "$pattern" ]]; then
        echo -e "${RED}Pattern cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    create_backup "$BEC_CONFIG" "Before adding scam pattern"
    
    temp_file=$(mktemp)
    jq --arg pattern "$pattern" \
       '.company_impersonation.scam_patterns.subjects += [$pattern] | .company_impersonation.scam_patterns.subjects |= unique' \
       "$BEC_CONFIG" > "$temp_file"
    
    if [[ $? -eq 0 ]]; then
        mv "$temp_file" "$BEC_CONFIG"
        fix_permissions "$BEC_CONFIG"
        echo -e "${GREEN}✓ Added scam pattern: $pattern${NC}"
    else
        echo -e "${RED}✗ Failed to add pattern${NC}"
        rm -f "$temp_file"
    fi
    
    pause_for_user
}

remove_scam_pattern() {
    echo ""
    echo -e "${BLUE}Current Scam Patterns:${NC}"
    mapfile -t patterns < <(jq -r '.company_impersonation.scam_patterns.subjects[]? // empty' "$BEC_CONFIG" 2>/dev/null)
    
    if [[ ${#patterns[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No scam patterns configured${NC}"
        pause_for_user
        return
    fi
    
    for i in "${!patterns[@]}"; do
        printf "%2d) %s\n" $((i+1)) "${patterns[$i]}"
    done
    
    echo ""
    echo -n -e "${YELLOW}Select number to remove (0 to cancel): ${NC}"
    read -r selection
    
    if [[ "$selection" == "0" ]]; then
        return
    fi
    
    if [[ "$selection" -gt 0 && "$selection" -le ${#patterns[@]} ]]; then
        remove_pattern="${patterns[$((selection-1))]}"
        
        create_backup "$BEC_CONFIG" "Before removing scam pattern"
        
        temp_file=$(mktemp)
        jq --arg pattern "$remove_pattern" \
           '.company_impersonation.scam_patterns.subjects -= [$pattern]' "$BEC_CONFIG" > "$temp_file"
        
        if [[ $? -eq 0 ]]; then
            mv "$temp_file" "$BEC_CONFIG"
            fix_permissions "$BEC_CONFIG"
            echo -e "${GREEN}✓ Removed scam pattern: $remove_pattern${NC}"
        else
            echo -e "${RED}✗ Failed to remove pattern${NC}"
            rm -f "$temp_file"
        fi
    else
        echo -e "${RED}Invalid selection${NC}"
    fi
    
    pause_for_user
}

test_impersonation_detection() {
    show_header
    echo -e "${WHITE}Test Company Impersonation Detection:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter sender email address: ${NC}"
    read -r test_sender
    
    echo -n -e "${YELLOW}Enter display name: ${NC}"
    read -r test_display
    
    echo -n -e "${YELLOW}Enter email subject: ${NC}"
    read -r test_subject
    
    echo ""
    echo -e "${BLUE}Testing impersonation detection...${NC}"
    echo ""
    
    # Create test script
    cat > /tmp/test_impersonation.py <<'EOF'
#!/usr/bin/env python3
import sys
import json
sys.path.insert(0, '/opt/spacyserver/modules')
from bec_detector import check_bec

test_email = {
    'from': sys.argv[1],
    'display_name': sys.argv[2],
    'subject': sys.argv[3],
    'body': 'Test email body',
    'spf_pass': False,
    'dkim_valid': False,
    'dmarc_pass': False
}

result = check_bec(test_email)
print(f"BEC Detected: {result['bec_detected']}")
print(f"Confidence: {result['bec_confidence']:.2%}")
print(f"Type: {result['bec_type']}")
if result.get('impersonated_executive'):
    print(f"Impersonated: {result['impersonated_executive']}")
print("\nRisk Factors:")
for factor in result['bec_risk_factors']:
    print(f"  • {factor}")
EOF
    
    chmod +x /tmp/test_impersonation.py
    $PYTHON /tmp/test_impersonation.py "$test_sender" "$test_display" "$test_subject" 2>/dev/null
    
    rm -f /tmp/test_impersonation.py
    
    pause_for_user
}

# Placeholder menus for other functions
email_filter_menu() {
    show_header
    echo -e "${WHITE}Email Filter Management${NC}"
    echo ""
    echo -e "${YELLOW}This section is under development.${NC}"
    echo -e "${BLUE}Features coming soon:${NC}"
    echo -e "  • Module management"
    echo -e "  • Size limits configuration"
    echo -e "  • Timeout settings"
    echo -e "  • Domain management"
    pause_for_user
}

# ============================================================================
# DATABASE BACKUP FUNCTIONS
# ============================================================================

backup_database() {
    show_header
    echo -e "${WHITE}Backup SpaCy Database:${NC}"
    echo ""
    
    timestamp=$(date +%Y%m%d_%H%M%S)
    backup_file="$BACKUP_DIR/spacy_db_backup_${timestamp}.sql"
    
    echo -e "${BLUE}Creating database backup...${NC}"
    echo -e "${YELLOW}Backup file: $(basename "$backup_file")${NC}"
    echo ""
    
    # Check if we can connect to the database
    if ! mysql -e "SELECT 1 FROM $DB_NAME.users LIMIT 1" &>/dev/null; then
        echo -e "${RED}✗ Cannot connect to database${NC}"
        echo -e "${YELLOW}Make sure MySQL is running and credentials are configured${NC}"
        pause_for_user
        return
    fi
    
    # Get database size
    db_size=$(mysql -e "SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'DB Size in MB' FROM information_schema.tables WHERE table_schema='$DB_NAME';" -s 2>/dev/null | tail -1)
    echo -e "${CYAN}Database size: ${db_size} MB${NC}"
    echo ""
    
    # Perform the backup
    echo -e "${BLUE}Running mysqldump...${NC}"
    if mysqldump --single-transaction --routines --triggers --events $DB_NAME > "$backup_file" 2>/dev/null; then
        # Compress the backup
        echo -e "${BLUE}Compressing backup...${NC}"
        gzip "$backup_file"
        backup_file="${backup_file}.gz"
        
        # Get compressed size
        file_size=$(stat -c %s "$backup_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
        
        echo ""
        echo -e "${GREEN}✓ Database backup created successfully!${NC}"
        echo -e "${CYAN}  File: $(basename "$backup_file")${NC}"
        echo -e "${CYAN}  Size: $file_size (compressed)${NC}"
        
        # Show table statistics
        echo ""
        echo -e "${WHITE}Tables backed up:${NC}"
        mysql -e "SELECT table_name AS 'Table', table_rows AS 'Rows' FROM information_schema.tables WHERE table_schema='$DB_NAME' ORDER BY table_rows DESC;" 2>/dev/null | head -15
    else
        echo -e "${RED}✗ Database backup failed!${NC}"
        echo -e "${YELLOW}Check MySQL credentials and permissions${NC}"
    fi
    
    pause_for_user
}

list_database_backups() {
    show_header
    echo -e "${WHITE}Database Backups:${NC}"
    echo ""
    
    if [[ ! -d "$BACKUP_DIR" ]]; then
        echo -e "${RED}Backup directory not found.${NC}"
        pause_for_user
        return
    fi
    
    db_backups=$(find "$BACKUP_DIR" -name "spacy_db_backup_*.sql*" 2>/dev/null | sort -r)
    
    if [[ -z "$db_backups" ]]; then
        echo -e "${YELLOW}No database backups found.${NC}"
    else
        echo -e "${GREEN}Available database backups:${NC}"
        echo ""
        echo "$db_backups" | while read -r backup_file; do
            filename=$(basename "$backup_file")
            file_date=$(stat -c %y "$backup_file" 2>/dev/null | cut -d' ' -f1-2)
            file_size=$(stat -c %s "$backup_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
            
            # Extract timestamp from filename
            if [[ "$filename" =~ spacy_db_backup_([0-9]{8}_[0-9]{6}) ]]; then
                backup_date="${BASH_REMATCH[1]}"
                formatted_date=$(echo "$backup_date" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)_\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
            else
                formatted_date="$file_date"
            fi
            
            echo -e "${BLUE}$filename${NC}"
            echo -e "  Created: $formatted_date"
            echo -e "  Size: $file_size"
            echo ""
        done
    fi
    
    pause_for_user
}

restore_database_backup() {
    show_header
    echo -e "${WHITE}Restore Database Backup:${NC}"
    echo ""
    echo -e "${RED}⚠️  WARNING: This will overwrite the current database!${NC}"
    echo -e "${RED}⚠️  All current email data, blocking rules, and analysis will be replaced!${NC}"
    echo ""
    
    db_backups=$(find "$BACKUP_DIR" -name "spacy_db_backup_*.sql*" 2>/dev/null | sort -r)
    
    if [[ -z "$db_backups" ]]; then
        echo -e "${YELLOW}No database backups found.${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Available database backups:${NC}"
    echo ""
    echo "$db_backups" | head -10 | nl
    
    echo ""
    echo -n -e "${YELLOW}Enter backup number to restore (1-10): ${NC}"
    read backup_num
    
    if [[ ! "$backup_num" =~ ^[1-9][0-9]*$ ]] || [[ "$backup_num" -gt 10 ]]; then
        echo -e "${RED}Invalid backup number.${NC}"
        pause_for_user
        return
    fi
    
    selected_backup=$(echo "$db_backups" | sed -n "${backup_num}p")
    
    if [[ -z "$selected_backup" ]]; then
        echo -e "${RED}Backup file not found.${NC}"
        pause_for_user
        return
    fi
    
    echo ""
    echo -e "${YELLOW}Selected: $(basename "$selected_backup")${NC}"
    echo ""
    echo -e "${RED}This will completely replace the current database!${NC}"
    echo -n -e "${RED}Are you SURE you want to restore this backup? [yes/NO]: ${NC}"
    read confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${BLUE}Restore cancelled.${NC}"
        pause_for_user
        return
    fi
    
    # Create a safety backup first
    echo ""
    echo -e "${BLUE}Creating safety backup of current database...${NC}"
    timestamp=$(date +%Y%m%d_%H%M%S)
    safety_backup="$BACKUP_DIR/spacy_db_safety_${timestamp}.sql.gz"
    
    if mysqldump --single-transaction $DB_NAME | gzip > "$safety_backup" 2>/dev/null; then
        echo -e "${GREEN}✓ Safety backup created: $(basename "$safety_backup")${NC}"
    else
        echo -e "${RED}✗ Could not create safety backup!${NC}"
        echo -n -e "${YELLOW}Continue anyway? [y/N]: ${NC}"
        read continue_anyway
        if [[ "$continue_anyway" != "y" ]]; then
            pause_for_user
            return
        fi
    fi
    
    # Restore the backup
    echo ""
    echo -e "${BLUE}Restoring database...${NC}"
    
    # Check if file is compressed
    if [[ "$selected_backup" == *.gz ]]; then
        echo -e "${CYAN}Decompressing and restoring...${NC}"
        if gunzip -c "$selected_backup" | mysql $DB_NAME 2>/dev/null; then
            echo -e "${GREEN}✓ Database restored successfully!${NC}"
        else
            echo -e "${RED}✗ Database restore failed!${NC}"
            echo -e "${YELLOW}You can restore the safety backup: $(basename "$safety_backup")${NC}"
        fi
    else
        echo -e "${CYAN}Restoring uncompressed backup...${NC}"
        if mysql $DB_NAME < "$selected_backup" 2>/dev/null; then
            echo -e "${GREEN}✓ Database restored successfully!${NC}"
        else
            echo -e "${RED}✗ Database restore failed!${NC}"
            echo -e "${YELLOW}You can restore the safety backup: $(basename "$safety_backup")${NC}"
        fi
    fi
    
    pause_for_user
}

full_system_backup() {
    show_header
    echo -e "${WHITE}Full System Backup:${NC}"
    echo ""
    echo -e "${BLUE}This will backup both configuration files and the database${NC}"
    echo ""
    
    timestamp=$(date +%Y%m%d_%H%M%S)
    
    # Create a subdirectory for this full backup
    full_backup_dir="$BACKUP_DIR/full_backup_${timestamp}"
    mkdir -p "$full_backup_dir"
    
    echo -e "${CYAN}Backup directory: $(basename "$full_backup_dir")${NC}"
    echo ""
    
    # Backup configurations
    echo -e "${BLUE}1. Backing up configuration files...${NC}"
    for config_file in "$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG"; do
        if [[ -f "$config_file" ]]; then
            basename_file=$(basename "$config_file")
            cp "$config_file" "$full_backup_dir/${basename_file}"
            echo -e "   ${GREEN}✓${NC} $basename_file"
        fi
    done
    
    # Backup database
    echo ""
    echo -e "${BLUE}2. Backing up database...${NC}"
    db_backup_file="$full_backup_dir/spacy_database.sql"
    
    if mysqldump --single-transaction --routines --triggers --events $DB_NAME > "$db_backup_file" 2>/dev/null; then
        gzip "$db_backup_file"
        echo -e "   ${GREEN}✓${NC} Database backed up and compressed"
    else
        echo -e "   ${RED}✗${NC} Database backup failed"
    fi
    
    # Backup Python modules (for safety)
    echo ""
    echo -e "${BLUE}3. Backing up custom Python modules...${NC}"
    modules_backup_dir="$full_backup_dir/modules"
    mkdir -p "$modules_backup_dir"
    
    # Copy key Python files
    for module in email_filter.py email_blocking.py; do
        if [[ -f "$SPACY_ROOT/$module" ]]; then
            cp "$SPACY_ROOT/$module" "$modules_backup_dir/"
            echo -e "   ${GREEN}✓${NC} $module"
        fi
    done
    
    # Copy modules directory
    if [[ -d "$SPACY_ROOT/modules" ]]; then
        cp -r "$SPACY_ROOT/modules" "$modules_backup_dir/"
        echo -e "   ${GREEN}✓${NC} modules directory"
    fi
    
    # Create a manifest file
    echo ""
    echo -e "${BLUE}4. Creating backup manifest...${NC}"
    cat > "$full_backup_dir/MANIFEST.txt" << EOF
SpaCy Full System Backup
========================
Date: $(date)
Timestamp: $timestamp
System: $(hostname)
User: $(whoami)

Contents:
---------
- Configuration Files:
  * bec_config.json
  * module_config.json
  * email_filter_config.json
  * authentication_config.json
  * threshold_config.json

- Database:
  * spacy_database.sql.gz (complete MySQL dump)
  * Tables included: $(mysql -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DB_NAME';" -s 2>/dev/null | tail -1)
  * Total records: $(mysql -e "SELECT SUM(table_rows) FROM information_schema.tables WHERE table_schema='$DB_NAME';" -s 2>/dev/null | tail -1)

- Python Modules:
  * email_filter.py
  * email_blocking.py
  * modules/ directory

Restore Instructions:
--------------------
1. Configuration files: Copy *.json files to /opt/spacyserver/config/
2. Database: gunzip -c spacy_database.sql.gz | mysql $DB_NAME
3. Modules: Copy to /opt/spacyserver/ (backup only, verify before overwriting)
EOF
    
    echo -e "   ${GREEN}✓${NC} Manifest created"
    
    # Create a tarball of everything
    echo ""
    echo -e "${BLUE}5. Creating compressed archive...${NC}"
    cd "$BACKUP_DIR"
    tar_file="full_backup_${timestamp}.tar.gz"
    
    if tar -czf "$tar_file" "full_backup_${timestamp}" 2>/dev/null; then
        echo -e "   ${GREEN}✓${NC} Archive created: $tar_file"
        
        # Get final size
        final_size=$(stat -c %s "$BACKUP_DIR/$tar_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
        
        # Clean up the uncompressed directory
        rm -rf "$full_backup_dir"
        
        echo ""
        echo -e "${GREEN}═══════════════════════════════════════${NC}"
        echo -e "${GREEN}✓ Full system backup completed!${NC}"
        echo -e "${GREEN}═══════════════════════════════════════${NC}"
        echo -e "${CYAN}Archive: $tar_file${NC}"
        echo -e "${CYAN}Size: $final_size${NC}"
        echo -e "${CYAN}Location: $BACKUP_DIR${NC}"
        
        # Copy to SDNAS1 backup location
        echo ""
        echo -e "${BLUE}6. Copying backup to SDNAS1...${NC}"
        sdnas_dir="/home/admin/backups/spacy_files"
        
        # Create directory if it doesn't exist
        if [[ ! -d "$sdnas_dir" ]]; then
            mkdir -p "$sdnas_dir" 2>/dev/null
        fi
        
        # Copy the backup file
        if [[ -d "$sdnas_dir" ]]; then
            if cp "$BACKUP_DIR/$tar_file" "$sdnas_dir/" 2>/dev/null; then
                echo -e "   ${GREEN}✓${NC} Backup copied to SDNAS1: $sdnas_dir/$tar_file"
                echo -e "${CYAN}SDNAS1 backup location: $sdnas_dir${NC}"
            else
                echo -e "   ${YELLOW}⚠${NC} Could not copy to SDNAS1 (check permissions/mount)"
            fi
        else
            echo -e "   ${YELLOW}⚠${NC} SDNAS1 directory not accessible: $sdnas_dir"
        fi
    else
        echo -e "   ${RED}✗${NC} Failed to create archive"
    fi
    
    pause_for_user
}

authentication_menu() {
    show_header
    echo -e "${WHITE}Authentication Configuration${NC}"
    echo ""
    echo -e "${YELLOW}This section is under development.${NC}"
    pause_for_user
}

threshold_menu() {
    show_header
    echo -e "${WHITE}Threshold Management${NC}"
    echo ""
    echo -e "${YELLOW}This section is under development.${NC}"
    pause_for_user
}

performance_monitoring_menu() {
    show_header
    echo -e "${WHITE}Performance Monitoring${NC}"
    echo ""
    echo -e "${YELLOW}This section is under development.${NC}"
    pause_for_user
}

realtime_analysis_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Real-time Email Analysis - SpacyMail Analyze${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} Analyze email file (.eml)"
        echo -e "${GREEN}2.${NC} Analyze raw email content"
        echo -e "${GREEN}3.${NC} Batch analyze multiple emails"
        echo -e "${GREEN}4.${NC} View recent analysis results"
        echo -e "${GREEN}5.${NC} Test BEC detection on sample"
        echo -e "${GREEN}6.${NC} Live mail queue analysis"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-6,9]: ${NC}"

        read choice
        case $choice in
            1) analyze_email_file ;;
            2) analyze_raw_email ;;
            3) batch_analyze_emails ;;
            4) view_recent_analysis ;;
            5) test_bec_detection ;;
            6) analyze_mail_queue ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

# ============================================================================
# EMAIL ANALYSIS FUNCTIONS
# ============================================================================

analyze_email_file() {
    show_header
    echo -e "${WHITE}Analyze Email File (.eml):${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter path to .eml file: ${NC}"
    read eml_path
    
    if [[ -z "$eml_path" ]]; then
        echo -e "${RED}Path cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Expand tilde for home directory
    eml_path="${eml_path/#\~/$HOME}"
    
    if [[ ! -f "$eml_path" ]]; then
        echo -e "${RED}File not found: $eml_path${NC}"
        pause_for_user
        return
    fi
    
    echo ""
    echo -e "${BLUE}Analyzing email...${NC}"
    echo ""
    
    # Run the email filter analysis
    analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$eml_path" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Analysis Results:${NC}"
        echo "$analysis_output"
        
        # Save to analysis log
        timestamp=$(date +%Y%m%d_%H%M%S)
        analysis_log="$LOG_DIR/analysis_${timestamp}.log"
        echo "File: $eml_path" > "$analysis_log"
        echo "Timestamp: $(date)" >> "$analysis_log"
        echo "" >> "$analysis_log"
        echo "$analysis_output" >> "$analysis_log"
        
        echo ""
        echo -e "${BLUE}Analysis saved to: $analysis_log${NC}"
    else
        echo -e "${RED}Analysis failed:${NC}"
        echo "$analysis_output"
    fi
    
    pause_for_user
}

analyze_raw_email() {
    show_header
    echo -e "${WHITE}Analyze Raw Email Content:${NC}"
    echo ""
    echo -e "${YELLOW}Enter/paste email content (end with line containing only 'END'):${NC}"
    echo ""
    
    # Create temp file for email content
    temp_email=$(mktemp --suffix=.eml)
    
    # Read multi-line input until 'END'
    while IFS= read -r line; do
        if [[ "$line" == "END" ]]; then
            break
        fi
        echo "$line" >> "$temp_email"
    done
    
    if [[ ! -s "$temp_email" ]]; then
        echo -e "${RED}No content provided.${NC}"
        rm -f "$temp_email"
        pause_for_user
        return
    fi
    
    echo ""
    echo -e "${BLUE}Analyzing email content...${NC}"
    echo ""
    
    # Run analysis on temp file
    analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$temp_email" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Analysis Results:${NC}"
        echo "$analysis_output"
        
        # Save to analysis log
        timestamp=$(date +%Y%m%d_%H%M%S)
        analysis_log="$LOG_DIR/analysis_raw_${timestamp}.log"
        echo "Type: Raw email input" > "$analysis_log"
        echo "Timestamp: $(date)" >> "$analysis_log"
        echo "" >> "$analysis_log"
        echo "$analysis_output" >> "$analysis_log"
        
        echo ""
        echo -e "${BLUE}Analysis saved to: $analysis_log${NC}"
    else
        echo -e "${RED}Analysis failed:${NC}"
        echo "$analysis_output"
    fi
    
    rm -f "$temp_email"
    pause_for_user
}

batch_analyze_emails() {
    show_header
    echo -e "${WHITE}Batch Analyze Multiple Emails:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter directory containing .eml files: ${NC}"
    read email_dir
    
    if [[ -z "$email_dir" ]]; then
        echo -e "${RED}Directory cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Expand tilde
    email_dir="${email_dir/#\~/$HOME}"
    
    if [[ ! -d "$email_dir" ]]; then
        echo -e "${RED}Directory not found: $email_dir${NC}"
        pause_for_user
        return
    fi
    
    # Find all .eml files
    mapfile -t eml_files < <(find "$email_dir" -maxdepth 1 -name "*.eml" -type f 2>/dev/null | sort)
    
    if [[ ${#eml_files[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No .eml files found in $email_dir${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Found ${#eml_files[@]} email files${NC}"
    echo ""
    echo -n -e "${YELLOW}Analyze all files? [y/N]: ${NC}"
    read confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi
    
    # Create batch results file
    timestamp=$(date +%Y%m%d_%H%M%S)
    batch_log="$LOG_DIR/batch_analysis_${timestamp}.log"
    summary_log="$LOG_DIR/batch_summary_${timestamp}.log"
    
    echo "Batch Analysis Report" > "$batch_log"
    echo "=====================" >> "$batch_log"
    echo "Directory: $email_dir" >> "$batch_log"
    echo "Timestamp: $(date)" >> "$batch_log"
    echo "Total Files: ${#eml_files[@]}" >> "$batch_log"
    echo "" >> "$batch_log"
    
    # Summary counters
    total=0
    suspicious=0
    clean=0
    errors=0
    
    echo ""
    echo -e "${BLUE}Processing emails...${NC}"
    
    for eml_file in "${eml_files[@]}"; do
        ((total++))
        filename=$(basename "$eml_file")
        echo -n -e "${BLUE}[$total/${#eml_files[@]}] Analyzing $filename...${NC} "
        
        echo "=" >> "$batch_log"
        echo "File: $filename" >> "$batch_log"
        echo "-" >> "$batch_log"
        
        analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$eml_file" 2>&1)
        
        if [[ $? -eq 0 ]]; then
            echo "$analysis_output" >> "$batch_log"
            
            # Check if suspicious
            if echo "$analysis_output" | grep -q "SUSPICIOUS\|HIGH RISK\|BEC DETECTED"; then
                ((suspicious++))
                echo -e "${RED}SUSPICIOUS${NC}"
                echo "$filename: SUSPICIOUS" >> "$summary_log"
            else
                ((clean++))
                echo -e "${GREEN}CLEAN${NC}"
                echo "$filename: CLEAN" >> "$summary_log"
            fi
        else
            ((errors++))
            echo -e "${YELLOW}ERROR${NC}"
            echo "ERROR: $analysis_output" >> "$batch_log"
            echo "$filename: ERROR" >> "$summary_log"
        fi
        
        echo "" >> "$batch_log"
    done
    
    echo ""
    echo -e "${WHITE}Batch Analysis Complete:${NC}"
    echo -e "${GREEN}  Clean: $clean${NC}"
    echo -e "${RED}  Suspicious: $suspicious${NC}"
    echo -e "${YELLOW}  Errors: $errors${NC}"
    echo -e "${BLUE}  Total: $total${NC}"
    echo ""
    echo -e "${BLUE}Full results: $batch_log${NC}"
    echo -e "${BLUE}Summary: $summary_log${NC}"
    
    pause_for_user
}

view_recent_analysis() {
    show_header
    echo -e "${WHITE}Recent Analysis Results:${NC}"
    echo ""
    
    if [[ ! -d "$LOG_DIR" ]]; then
        echo -e "${RED}Log directory not found.${NC}"
        pause_for_user
        return
    fi
    
    # Find recent analysis logs
    mapfile -t analysis_logs < <(find "$LOG_DIR" -name "analysis_*.log" -o -name "batch_*.log" 2>/dev/null | sort -r | head -20)
    
    if [[ ${#analysis_logs[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No analysis logs found.${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Recent analysis logs:${NC}"
    echo ""
    
    for i in "${!analysis_logs[@]}"; do
        log_file="${analysis_logs[$i]}"
        log_name=$(basename "$log_file")
        log_date=$(stat -c %y "$log_file" 2>/dev/null | cut -d' ' -f1-2)
        log_size=$(stat -c %s "$log_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
        
        printf "%2d) %-40s  %s  %s\n" $((i+1)) "$log_name" "$log_date" "$log_size"
    done
    
    echo ""
    echo -n -e "${YELLOW}Enter log number to view (or 0 to return): ${NC}"
    read log_choice
    
    if [[ "$log_choice" == "0" ]]; then
        return
    fi
    
    if [[ ! "$log_choice" =~ ^[0-9]+$ ]] || [[ "$log_choice" -lt 1 ]] || [[ "$log_choice" -gt ${#analysis_logs[@]} ]]; then
        echo -e "${RED}Invalid selection.${NC}"
        pause_for_user
        return
    fi
    
    selected_log="${analysis_logs[$((log_choice-1))]}"
    
    echo ""
    echo -e "${BLUE}Contents of $(basename "$selected_log"):${NC}"
    echo -e "${CYAN}=${NC}"
    
    # Use less if available, otherwise cat
    if command -v less >/dev/null 2>&1; then
        less "$selected_log"
    else
        cat "$selected_log"
    fi
    
    pause_for_user
}

test_bec_detection() {
    show_header
    echo -e "${WHITE}Test BEC Detection on Sample:${NC}"
    echo ""
    echo -e "${YELLOW}This will create a sample suspicious email for testing.${NC}"
    echo ""
    
    echo -e "${GREEN}Select sample type:${NC}"
    echo -e "${GREEN}1.${NC} CEO Fraud (Urgent wire transfer request)"
    echo -e "${GREEN}2.${NC} Invoice Fraud (Changed payment details)"
    echo -e "${GREEN}3.${NC} Account Compromise (Password reset request)"
    echo -e "${GREEN}4.${NC} Gift Card Scam"
    echo -e "${GREEN}5.${NC} Payroll Diversion"
    echo ""
    echo -n -e "${YELLOW}Select [1-5]: ${NC}"
    read sample_type
    
    # Create sample email based on selection
    temp_sample=$(mktemp --suffix=.eml)
    
    case $sample_type in
        1)
            cat > "$temp_sample" << 'EOF'
From: CEO John Smith <ceo@companyy.com>
To: accounting@company.com
Subject: Urgent - Wire Transfer Required
Date: Mon, 1 Jan 2024 09:00:00 -0500

Dear Accounting Team,

I need you to process an urgent wire transfer of $45,000 to our new vendor immediately. I'm in meetings all day and cannot be reached by phone.

Please wire the funds to:
Bank: International Business Bank
Account: 987654321
Routing: 123456789

This is extremely urgent and confidential. Please confirm once complete.

Best,
John Smith
CEO
EOF
            ;;
        2)
            cat > "$temp_sample" << 'EOF'
From: Vendor Support <support@vend0r.com>
To: accounts@company.com
Subject: Important - Updated Banking Information
Date: Mon, 1 Jan 2024 10:00:00 -0500

Dear Valued Customer,

We are writing to inform you that we have updated our banking information. Please update your records and send all future payments to:

New Account Details:
Bank Name: Global Financial Corp
Account Number: 112233445566
SWIFT: GFCOUS33

Please confirm receipt of this message and update your payment systems immediately to avoid any service interruptions.

Thank you for your cooperation.

Vendor Accounts Team
EOF
            ;;
        3)
            cat > "$temp_sample" << 'EOF'
From: IT Support <itsupport@companyname.net>
To: all@company.com
Subject: Security Alert - Password Reset Required
Date: Mon, 1 Jan 2024 11:00:00 -0500

SECURITY NOTICE

Our security team has detected unusual activity on your account. To protect your data, you must reset your password immediately.

Click here to reset your password: http://company-security.fake/reset

If you do not reset your password within 2 hours, your account will be locked.

IT Security Team
EOF
            ;;
        4)
            cat > "$temp_sample" << 'EOF'
From: Manager <manager@gmail.com>
To: employee@company.com
Subject: Quick favor
Date: Mon, 1 Jan 2024 12:00:00 -0500

Hi,

I'm in a client meeting and need your help urgently. Can you purchase $500 in Amazon gift cards for client gifts? I'll reimburse you later today.

Please send me the gift card codes as soon as you get them.

Thanks!
Sent from my iPhone
EOF
            ;;
        5)
            cat > "$temp_sample" << 'EOF'
From: HR Department <hr@company-hr.org>
To: employee@company.com
Subject: Direct Deposit Update Required
Date: Mon, 1 Jan 2024 13:00:00 -0500

Dear Employee,

Due to a system upgrade, all employees must update their direct deposit information by end of day.

Please click the link below to update your banking details:
http://company-payroll.fake/update

Failure to update may result in delayed payment.

Human Resources
EOF
            ;;
        *)
            echo -e "${RED}Invalid selection.${NC}"
            rm -f "$temp_sample"
            pause_for_user
            return
            ;;
    esac
    
    echo ""
    echo -e "${BLUE}Analyzing sample BEC email...${NC}"
    echo ""
    
    # Run analysis
    analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$temp_sample" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}BEC Detection Results:${NC}"
        echo "$analysis_output"
        
        echo ""
        echo -e "${YELLOW}Sample Analysis Summary:${NC}"
        
        # Extract key indicators
        if echo "$analysis_output" | grep -q "BEC DETECTED\|HIGH RISK"; then
            echo -e "${RED}✓ BEC/Fraud indicators detected${NC}"
        else
            echo -e "${YELLOW}⚠ Review detection sensitivity${NC}"
        fi
        
        if echo "$analysis_output" | grep -q "urgency"; then
            echo -e "${GREEN}✓ Urgency patterns detected${NC}"
        fi
        
        if echo "$analysis_output" | grep -q "financial"; then
            echo -e "${GREEN}✓ Financial keywords detected${NC}"
        fi
        
        if echo "$analysis_output" | grep -q "authentication.*failed"; then
            echo -e "${GREEN}✓ Authentication issues detected${NC}"
        fi
    else
        echo -e "${RED}Analysis failed:${NC}"
        echo "$analysis_output"
    fi
    
    rm -f "$temp_sample"
    pause_for_user
}

analyze_mail_queue() {
    show_header
    echo -e "${WHITE}Live Mail Queue Analysis:${NC}"
    echo ""
    
    if ! command -v postqueue >/dev/null 2>&1; then
        echo -e "${RED}Postfix tools not available.${NC}"
        pause_for_user
        return
    fi
    
    # Check mail queue
    queue_output=$(postqueue -p 2>/dev/null)
    queue_count=$(echo "$queue_output" | tail -1 | grep -o '[0-9]*' || echo "0")
    
    if [[ "$queue_count" == "0" ]]; then
        echo -e "${YELLOW}Mail queue is empty.${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Found $queue_count messages in queue${NC}"
    echo ""
    
    echo -e "${GREEN}Options:${NC}"
    echo -e "${GREEN}1.${NC} Analyze all queued messages"
    echo -e "${GREEN}2.${NC} Analyze specific message by ID"
    echo -e "${GREEN}3.${NC} Show queue summary only"
    echo ""
    echo -n -e "${YELLOW}Select [1-3]: ${NC}"
    read queue_choice
    
    case $queue_choice in
        1)
            echo ""
            echo -e "${BLUE}Analyzing all queued messages...${NC}"
            
            # Get message IDs
            mapfile -t msg_ids < <(postqueue -p 2>/dev/null | grep '^[A-F0-9]' | awk '{print $1}' | tr -d '*!')
            
            suspicious_count=0
            clean_count=0
            
            for msg_id in "${msg_ids[@]}"; do
                echo -n -e "${BLUE}Analyzing $msg_id... ${NC}"
                
                # Export message
                temp_msg=$(mktemp --suffix=.eml)
                postcat -q "$msg_id" 2>/dev/null > "$temp_msg"
                
                if [[ -s "$temp_msg" ]]; then
                    analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$temp_msg" 2>&1)
                    
                    if echo "$analysis_output" | grep -q "SUSPICIOUS\|HIGH RISK"; then
                        echo -e "${RED}SUSPICIOUS${NC}"
                        ((suspicious_count++))
                    else
                        echo -e "${GREEN}CLEAN${NC}"
                        ((clean_count++))
                    fi
                else
                    echo -e "${YELLOW}SKIP${NC}"
                fi
                
                rm -f "$temp_msg"
            done
            
            echo ""
            echo -e "${WHITE}Queue Analysis Summary:${NC}"
            echo -e "${GREEN}  Clean: $clean_count${NC}"
            echo -e "${RED}  Suspicious: $suspicious_count${NC}"
            ;;
            
        2)
            echo ""
            echo -e "${BLUE}Current queue:${NC}"
            postqueue -p 2>/dev/null | head -20
            
            echo ""
            echo -n -e "${YELLOW}Enter message ID: ${NC}"
            read msg_id
            
            if [[ -z "$msg_id" ]]; then
                echo -e "${RED}Message ID required.${NC}"
                pause_for_user
                return
            fi
            
            # Export and analyze
            temp_msg=$(mktemp --suffix=.eml)
            postcat -q "$msg_id" 2>/dev/null > "$temp_msg"
            
            if [[ -s "$temp_msg" ]]; then
                echo ""
                echo -e "${BLUE}Analyzing message $msg_id...${NC}"
                echo ""
                
                analysis_output=$($PYTHON "$SPACY_ROOT/email_filter.py" analyze "$temp_msg" 2>&1)
                echo "$analysis_output"
            else
                echo -e "${RED}Could not retrieve message.${NC}"
            fi
            
            rm -f "$temp_msg"
            ;;
            
        3)
            echo ""
            echo -e "${BLUE}Mail Queue Summary:${NC}"
            postqueue -p 2>/dev/null
            ;;
            
        *)
            echo -e "${RED}Invalid selection.${NC}"
            ;;
    esac
    
    pause_for_user
}

# ============================================================================
# DNS DIAGNOSTICS FUNCTIONS
# ============================================================================

dns_diagnostics_menu() {
    while true; do
        show_header
        echo -e "${WHITE}DNS Diagnostics & Testing:${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} Test DNS resolution for a domain"
        echo -e "${GREEN}2.${NC} Check SPF records"
        echo -e "${GREEN}3.${NC} Check DMARC policy"
        echo -e "${GREEN}4.${NC} Check MX records"
        echo -e "${GREEN}5.${NC} Check DKIM selector"
        echo -e "${GREEN}6.${NC} Full email authentication check"
        echo -e "${GREEN}7.${NC} Test DNS server connectivity"
        echo -e "${GREEN}8.${NC} Diagnose recent email rejection"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-8,9]: ${NC}"

        read choice
        case $choice in
            1) test_dns_resolution ;;
            2) check_spf_records ;;
            3) check_dmarc_policy ;;
            4) check_mx_records ;;
            5) check_dkim_selector ;;
            6) full_email_auth_check ;;
            7) test_dns_connectivity ;;
            8) diagnose_email_rejection ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

test_dns_resolution() {
    show_header
    echo -e "${WHITE}Test DNS Resolution:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to test (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Clean domain input
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${BLUE}Testing DNS resolution for: $domain${NC}"
    echo -e "${CYAN}=${NC}"
    
    # Test with different tools and methods
    echo -e "${GREEN}1. Using 'host' command:${NC}"
    if command -v host >/dev/null 2>&1; then
        host_output=$(host "$domain" 2>&1)
        if [[ $? -eq 0 ]]; then
            echo "$host_output" | head -5
            echo -e "${GREEN}✓ Resolution successful${NC}"
        else
            echo "$host_output"
            echo -e "${RED}✗ Resolution failed${NC}"
        fi
    else
        echo -e "${YELLOW}'host' command not available${NC}"
    fi
    
    echo ""
    echo -e "${GREEN}2. Using 'nslookup' command:${NC}"
    if command -v nslookup >/dev/null 2>&1; then
        nslookup_output=$(nslookup "$domain" 2>&1)
        if [[ $? -eq 0 ]]; then
            echo "$nslookup_output" | grep -A2 "^Name:" || echo "$nslookup_output" | head -10
            echo -e "${GREEN}✓ Resolution successful${NC}"
        else
            echo "$nslookup_output"
            echo -e "${RED}✗ Resolution failed${NC}"
        fi
    else
        echo -e "${YELLOW}'nslookup' command not available${NC}"
    fi
    
    echo ""
    echo -e "${GREEN}3. Using 'dig' command:${NC}"
    if command -v dig >/dev/null 2>&1; then
        dig_output=$(dig +short "$domain" 2>&1)
        if [[ -n "$dig_output" ]] && [[ ! "$dig_output" =~ "connection timed out" ]]; then
            echo "$dig_output"
            echo -e "${GREEN}✓ Resolution successful${NC}"
            
            # Also show response time
            response_time=$(dig "$domain" | grep "Query time:" | awk '{print $4" "$5}')
            if [[ -n "$response_time" ]]; then
                echo -e "${BLUE}Query time: $response_time${NC}"
            fi
        else
            echo -e "${RED}✗ No results or timeout${NC}"
            # Try with trace for more details
            echo -e "${YELLOW}Attempting trace...${NC}"
            dig +trace "$domain" 2>&1 | tail -10
        fi
    else
        echo -e "${YELLOW}'dig' command not available${NC}"
    fi
    
    echo ""
    echo -e "${GREEN}4. Using Python DNS resolver:${NC}"
    $PYTHON -c "
import sys
try:
    import dns.resolver
    domain = '$domain'
    
    # Try A records
    try:
        answers = dns.resolver.resolve(domain, 'A')
        print(f'A Records:')
        for rdata in answers:
            print(f'  {rdata}')
        print('✓ Python resolution successful')
    except dns.resolver.NXDOMAIN:
        print(f'✗ Domain {domain} does not exist')
    except dns.resolver.NoAnswer:
        print(f'✗ No A records found for {domain}')
    except Exception as e:
        print(f'✗ Error resolving {domain}: {e}')
        
except ImportError:
    print('DNS library not available')
    import socket
    try:
        ip = socket.gethostbyname('$domain')
        print(f'Socket resolution: {ip}')
        print('✓ Basic resolution successful')
    except socket.gaierror as e:
        print(f'✗ Socket resolution failed: {e}')
" 2>&1
    
    echo ""
    echo -e "${GREEN}5. Testing DNS server response:${NC}"
    # Test if DNS servers are reachable
    dns_servers=("8.8.8.8" "1.1.1.1" "$(grep nameserver /etc/resolv.conf 2>/dev/null | head -1 | awk '{print $2}')")
    
    for dns_server in "${dns_servers[@]}"; do
        if [[ -n "$dns_server" ]]; then
            echo -n -e "${BLUE}Testing DNS server $dns_server: ${NC}"
            if ping -c 1 -W 2 "$dns_server" >/dev/null 2>&1; then
                echo -e "${GREEN}✓ Reachable${NC}"
                
                # Try resolution using this specific DNS
                if command -v dig >/dev/null 2>&1; then
                    result=$(dig @"$dns_server" +short "$domain" 2>&1 | head -1)
                    if [[ -n "$result" ]] && [[ ! "$result" =~ "connection timed out" ]]; then
                        echo -e "  Result: $result"
                    fi
                fi
            else
                echo -e "${RED}✗ Unreachable${NC}"
            fi
        fi
    done
    
    pause_for_user
}

check_spf_records() {
    show_header
    echo -e "${WHITE}Check SPF Records:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to check SPF (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${BLUE}Checking SPF records for: $domain${NC}"
    echo -e "${CYAN}=${NC}"
    
    # Check SPF record
    if command -v dig >/dev/null 2>&1; then
        spf_record=$(dig +short TXT "$domain" 2>&1 | grep "v=spf1" | tr -d '"')
        
        if [[ -n "$spf_record" ]]; then
            echo -e "${GREEN}✓ SPF record found:${NC}"
            echo "$spf_record"
            echo ""
            
            # Parse SPF record
            echo -e "${BLUE}SPF Analysis:${NC}"
            
            # Check for includes
            if [[ "$spf_record" =~ include: ]]; then
                echo -e "${CYAN}Includes:${NC}"
                echo "$spf_record" | grep -o 'include:[^ ]*' | sed 's/include:/  - /'
            fi
            
            # Check for IP addresses
            if [[ "$spf_record" =~ ip[46]: ]]; then
                echo -e "${CYAN}IP addresses:${NC}"
                echo "$spf_record" | grep -o 'ip[46]:[^ ]*' | sed 's/^/  - /'
            fi
            
            # Check for all mechanism
            if [[ "$spf_record" =~ ([+-~?])all ]]; then
                all_mechanism="${BASH_REMATCH[1]}all"
                case "$all_mechanism" in
                    "-all")
                        echo -e "${GREEN}Policy: Hard fail (-all) - Strict${NC}"
                        ;;
                    "~all")
                        echo -e "${YELLOW}Policy: Soft fail (~all) - Moderate${NC}"
                        ;;
                    "+all")
                        echo -e "${RED}Policy: Pass all (+all) - INSECURE${NC}"
                        ;;
                    "?all")
                        echo -e "${YELLOW}Policy: Neutral (?all) - Permissive${NC}"
                        ;;
                esac
            fi
            
            # Check record length
            record_length=${#spf_record}
            if [[ $record_length -gt 255 ]]; then
                echo -e "${YELLOW}⚠ Warning: SPF record length ($record_length) exceeds 255 characters${NC}"
            fi
            
        else
            echo -e "${RED}✗ No SPF record found${NC}"
            echo -e "${YELLOW}This domain does not have SPF configured.${NC}"
        fi
    else
        echo -e "${YELLOW}'dig' command not available, trying alternative method${NC}"
        
        # Try with nslookup
        if command -v nslookup >/dev/null 2>&1; then
            nslookup -type=TXT "$domain" 2>&1 | grep "v=spf1"
        fi
    fi
    
    echo ""
    echo -e "${BLUE}Testing SPF with Python:${NC}"
    $PYTHON -c "
import sys
try:
    import dns.resolver
    domain = '$domain'
    
    try:
        answers = dns.resolver.resolve(domain, 'TXT')
        spf_found = False
        for rdata in answers:
            txt_record = str(rdata).strip('\"')
            if txt_record.startswith('v=spf1'):
                print(f'SPF Record: {txt_record}')
                spf_found = True
                
                # Check for DNS lookups limit
                import re
                includes = re.findall(r'include:', txt_record)
                if len(includes) > 10:
                    print(f'⚠ Warning: {len(includes)} includes found (limit is 10)')
                    
        if not spf_found:
            print('✗ No SPF record found')
            
    except dns.resolver.NXDOMAIN:
        print(f'✗ Domain {domain} does not exist')
    except Exception as e:
        print(f'✗ Error: {e}')
        
except ImportError:
    print('DNS library not available for detailed check')
" 2>&1
    
    pause_for_user
}

check_dmarc_policy() {
    show_header
    echo -e "${WHITE}Check DMARC Policy:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to check DMARC (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    dmarc_domain="_dmarc.$domain"
    
    echo ""
    echo -e "${BLUE}Checking DMARC policy for: $domain${NC}"
    echo -e "${CYAN}=${NC}"
    
    # Check DMARC record
    if command -v dig >/dev/null 2>&1; then
        dmarc_record=$(dig +short TXT "$dmarc_domain" 2>&1 | grep "v=DMARC1" | tr -d '"')
        
        if [[ -n "$dmarc_record" ]]; then
            echo -e "${GREEN}✓ DMARC record found:${NC}"
            echo "$dmarc_record"
            echo ""
            
            # Parse DMARC record
            echo -e "${BLUE}DMARC Analysis:${NC}"
            
            # Check policy
            if [[ "$dmarc_record" =~ p=([^;]+) ]]; then
                policy="${BASH_REMATCH[1]}"
                case "$policy" in
                    "none")
                        echo -e "${YELLOW}Policy: Monitor only (p=none)${NC}"
                        ;;
                    "quarantine")
                        echo -e "${BLUE}Policy: Quarantine (p=quarantine)${NC}"
                        ;;
                    "reject")
                        echo -e "${GREEN}Policy: Reject (p=reject) - Strict${NC}"
                        ;;
                esac
            fi
            
            # Check subdomain policy
            if [[ "$dmarc_record" =~ sp=([^;]+) ]]; then
                sp="${BASH_REMATCH[1]}"
                echo -e "${CYAN}Subdomain policy: $sp${NC}"
            fi
            
            # Check percentage
            if [[ "$dmarc_record" =~ pct=([^;]+) ]]; then
                pct="${BASH_REMATCH[1]}"
                echo -e "${CYAN}Percentage: $pct%${NC}"
            fi
            
            # Check RUA (aggregate reports)
            if [[ "$dmarc_record" =~ rua=([^;]+) ]]; then
                rua="${BASH_REMATCH[1]}"
                echo -e "${CYAN}Aggregate reports to: $rua${NC}"
            fi
            
            # Check RUF (forensic reports)
            if [[ "$dmarc_record" =~ ruf=([^;]+) ]]; then
                ruf="${BASH_REMATCH[1]}"
                echo -e "${CYAN}Forensic reports to: $ruf${NC}"
            fi
            
            # Check alignment
            if [[ "$dmarc_record" =~ aspf=([^;]+) ]]; then
                aspf="${BASH_REMATCH[1]}"
                echo -e "${CYAN}SPF alignment: $aspf${NC}"
            fi
            
            if [[ "$dmarc_record" =~ adkim=([^;]+) ]]; then
                adkim="${BASH_REMATCH[1]}"
                echo -e "${CYAN}DKIM alignment: $adkim${NC}"
            fi
            
        else
            echo -e "${RED}✗ No DMARC record found${NC}"
            echo -e "${YELLOW}Checking organizational domain...${NC}"
            
            # Try parent domain if subdomain
            if [[ "$domain" =~ \. ]]; then
                parent_domain=$(echo "$domain" | cut -d. -f2-)
                if [[ "$parent_domain" =~ \. ]]; then
                    parent_dmarc="_dmarc.$parent_domain"
                    parent_record=$(dig +short TXT "$parent_dmarc" 2>&1 | grep "v=DMARC1" | tr -d '"')
                    if [[ -n "$parent_record" ]]; then
                        echo -e "${BLUE}Found at parent domain ($parent_domain):${NC}"
                        echo "$parent_record"
                    fi
                fi
            fi
        fi
    else
        echo -e "${YELLOW}'dig' command not available${NC}"
    fi
    
    pause_for_user
}

check_mx_records() {
    show_header
    echo -e "${WHITE}Check MX Records:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to check MX (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${BLUE}Checking MX records for: $domain${NC}"
    echo -e "${CYAN}=${NC}"
    
    if command -v dig >/dev/null 2>&1; then
        mx_records=$(dig +short MX "$domain" 2>&1 | sort -n)
        
        if [[ -n "$mx_records" ]]; then
            echo -e "${GREEN}✓ MX records found:${NC}"
            echo "$mx_records"
            echo ""
            
            # Resolve each MX host
            echo -e "${BLUE}MX host resolution:${NC}"
            echo "$mx_records" | while read priority mx_host; do
                mx_host=$(echo "$mx_host" | sed 's/\.$//')
                if [[ -n "$mx_host" ]]; then
                    mx_ip=$(dig +short A "$mx_host" 2>&1 | head -1)
                    if [[ -n "$mx_ip" ]]; then
                        echo -e "  ${GREEN}✓${NC} $mx_host → $mx_ip"
                    else
                        echo -e "  ${RED}✗${NC} $mx_host → Unable to resolve"
                    fi
                fi
            done
            
            # Test connectivity to primary MX
            primary_mx=$(echo "$mx_records" | head -1 | awk '{print $2}' | sed 's/\.$//')
            if [[ -n "$primary_mx" ]]; then
                echo ""
                echo -e "${BLUE}Testing primary MX ($primary_mx):${NC}"
                
                # Test port 25 connectivity
                if command -v nc >/dev/null 2>&1; then
                    echo -n -e "  Port 25 (SMTP): "
                    if nc -z -w2 "$primary_mx" 25 2>/dev/null; then
                        echo -e "${GREEN}✓ Open${NC}"
                    else
                        echo -e "${RED}✗ Closed/Filtered${NC}"
                    fi
                fi
            fi
            
        else
            echo -e "${RED}✗ No MX records found${NC}"
            echo -e "${YELLOW}This domain cannot receive email directly.${NC}"
        fi
    else
        echo -e "${YELLOW}'dig' command not available${NC}"
    fi
    
    pause_for_user
}

check_dkim_selector() {
    show_header
    echo -e "${WHITE}Check DKIM Selector:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    echo -n -e "${YELLOW}Enter DKIM selector (e.g., google, default, s1): ${NC}"
    read selector
    
    if [[ -z "$selector" ]]; then
        echo -e "${YELLOW}No selector provided, trying common selectors...${NC}"
        selectors=("google" "default" "s1" "s2" "selector1" "selector2" "k1" "mail" "dkim")
    else
        selectors=("$selector")
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${BLUE}Checking DKIM for: $domain${NC}"
    echo -e "${CYAN}=${NC}"
    
    found_dkim=false
    
    for sel in "${selectors[@]}"; do
        dkim_record="${sel}._domainkey.${domain}"
        echo -n -e "${BLUE}Testing selector '$sel': ${NC}"
        
        if command -v dig >/dev/null 2>&1; then
            dkim_txt=$(dig +short TXT "$dkim_record" 2>&1 | grep -E "v=DKIM1|k=rsa" | tr -d '"')
            
            if [[ -n "$dkim_txt" ]]; then
                echo -e "${GREEN}✓ Found${NC}"
                echo -e "  Record: $dkim_txt"
                found_dkim=true
                
                # Parse DKIM record
                if [[ "$dkim_txt" =~ p=([^;]+) ]]; then
                    key="${BASH_REMATCH[1]}"
                    if [[ ${#key} -gt 50 ]]; then
                        echo -e "  ${GREEN}✓ Public key present (${#key} chars)${NC}"
                    else
                        echo -e "  ${YELLOW}⚠ Short public key${NC}"
                    fi
                fi
            else
                echo -e "${YELLOW}Not found${NC}"
            fi
        fi
    done
    
    if ! $found_dkim; then
        echo ""
        echo -e "${RED}✗ No DKIM records found with tested selectors${NC}"
        echo -e "${YELLOW}The domain might use a different selector.${NC}"
    fi
    
    pause_for_user
}

full_email_auth_check() {
    show_header
    echo -e "${WHITE}Full Email Authentication Check:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to check (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║           Full Authentication Check for $domain              ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # Create summary variables
    dns_ok=false
    spf_ok=false
    dmarc_ok=false
    mx_ok=false
    
    # 1. Basic DNS Resolution
    echo -e "${WHITE}1. DNS Resolution:${NC}"
    if command -v dig >/dev/null 2>&1; then
        a_record=$(dig +short A "$domain" 2>&1 | head -1)
        if [[ -n "$a_record" ]] && [[ ! "$a_record" =~ "connection timed out" ]]; then
            echo -e "   ${GREEN}✓ Domain resolves to: $a_record${NC}"
            dns_ok=true
        else
            echo -e "   ${RED}✗ Domain does not resolve${NC}"
        fi
    fi
    echo ""
    
    # 2. MX Records
    echo -e "${WHITE}2. MX Records:${NC}"
    if command -v dig >/dev/null 2>&1; then
        mx_records=$(dig +short MX "$domain" 2>&1 | head -3)
        if [[ -n "$mx_records" ]]; then
            echo -e "   ${GREEN}✓ MX records found:${NC}"
            echo "$mx_records" | sed 's/^/     /'
            mx_ok=true
        else
            echo -e "   ${RED}✗ No MX records${NC}"
        fi
    fi
    echo ""
    
    # 3. SPF Record
    echo -e "${WHITE}3. SPF Record:${NC}"
    if command -v dig >/dev/null 2>&1; then
        spf_record=$(dig +short TXT "$domain" 2>&1 | grep "v=spf1" | head -1 | tr -d '"')
        if [[ -n "$spf_record" ]]; then
            echo -e "   ${GREEN}✓ SPF configured${NC}"
            # Check policy
            if [[ "$spf_record" =~ -all ]]; then
                echo -e "   ${GREEN}✓ Strict policy (-all)${NC}"
                spf_ok=true
            elif [[ "$spf_record" =~ ~all ]]; then
                echo -e "   ${YELLOW}⚠ Soft fail policy (~all)${NC}"
                spf_ok=true
            else
                echo -e "   ${YELLOW}⚠ Permissive policy${NC}"
            fi
        else
            echo -e "   ${RED}✗ No SPF record${NC}"
        fi
    fi
    echo ""
    
    # 4. DMARC Record
    echo -e "${WHITE}4. DMARC Record:${NC}"
    if command -v dig >/dev/null 2>&1; then
        dmarc_record=$(dig +short TXT "_dmarc.$domain" 2>&1 | grep "v=DMARC1" | head -1 | tr -d '"')
        if [[ -n "$dmarc_record" ]]; then
            echo -e "   ${GREEN}✓ DMARC configured${NC}"
            # Extract policy
            if [[ "$dmarc_record" =~ p=([^;]+) ]]; then
                policy="${BASH_REMATCH[1]}"
                case "$policy" in
                    "reject")
                        echo -e "   ${GREEN}✓ Reject policy${NC}"
                        dmarc_ok=true
                        ;;
                    "quarantine")
                        echo -e "   ${BLUE}✓ Quarantine policy${NC}"
                        dmarc_ok=true
                        ;;
                    "none")
                        echo -e "   ${YELLOW}⚠ Monitor only${NC}"
                        ;;
                esac
            fi
        else
            echo -e "   ${RED}✗ No DMARC record${NC}"
        fi
    fi
    echo ""
    
    # 5. DKIM (check common selectors)
    echo -e "${WHITE}5. DKIM Selectors:${NC}"
    common_selectors=("google" "default" "s1" "selector1" "k1")
    dkim_found=false
    
    for selector in "${common_selectors[@]}"; do
        if command -v dig >/dev/null 2>&1; then
            dkim_record=$(dig +short TXT "${selector}._domainkey.${domain}" 2>&1 | grep -E "v=DKIM1|k=rsa" | head -1)
            if [[ -n "$dkim_record" ]]; then
                echo -e "   ${GREEN}✓ DKIM selector '$selector' found${NC}"
                dkim_found=true
                break
            fi
        fi
    done
    
    if ! $dkim_found; then
        echo -e "   ${YELLOW}⚠ No common DKIM selectors found${NC}"
    fi
    echo ""
    
    # 6. Summary and Recommendations
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                         SUMMARY                              ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    
    score=0
    max_score=5
    
    if $dns_ok; then ((score++)); fi
    if $mx_ok; then ((score++)); fi
    if $spf_ok; then ((score++)); fi
    if $dmarc_ok; then ((score++)); fi
    if $dkim_found; then ((score++)); fi
    
    echo -e "${WHITE}Authentication Score: $score/$max_score${NC}"
    
    if [[ $score -eq 5 ]]; then
        echo -e "${GREEN}✓ Excellent email authentication setup${NC}"
    elif [[ $score -ge 3 ]]; then
        echo -e "${BLUE}✓ Good email authentication setup${NC}"
    elif [[ $score -ge 2 ]]; then
        echo -e "${YELLOW}⚠ Basic email authentication${NC}"
    else
        echo -e "${RED}✗ Poor email authentication${NC}"
    fi
    
    echo ""
    echo -e "${WHITE}Recommendations:${NC}"
    
    if ! $dns_ok; then
        echo -e "${RED}• Fix DNS resolution issues${NC}"
    fi
    if ! $mx_ok; then
        echo -e "${RED}• Configure MX records${NC}"
    fi
    if ! $spf_ok; then
        echo -e "${YELLOW}• Add or strengthen SPF record${NC}"
    fi
    if ! $dmarc_ok; then
        echo -e "${YELLOW}• Implement DMARC policy${NC}"
    fi
    if ! $dkim_found; then
        echo -e "${YELLOW}• Configure DKIM signing${NC}"
    fi
    
    pause_for_user
}

test_dns_connectivity() {
    show_header
    echo -e "${WHITE}Test DNS Server Connectivity:${NC}"
    echo ""
    
    # Get current DNS servers
    echo -e "${BLUE}Current DNS Configuration:${NC}"
    echo -e "${CYAN}/etc/resolv.conf:${NC}"
    grep -E "^nameserver" /etc/resolv.conf 2>/dev/null | head -5
    echo ""
    
    # Get list of DNS servers to test
    dns_servers=()
    
    # Add system DNS servers
    while IFS= read -r line; do
        dns_server=$(echo "$line" | awk '{print $2}')
        dns_servers+=("$dns_server:System")
    done < <(grep -E "^nameserver" /etc/resolv.conf 2>/dev/null)
    
    # Add common public DNS servers
    dns_servers+=("8.8.8.8:Google" "8.8.4.4:Google2" "1.1.1.1:Cloudflare" "9.9.9.9:Quad9")
    
    echo -e "${WHITE}Testing DNS Servers:${NC}"
    echo -e "${CYAN}=${NC}"
    
    failed_servers=()
    successful_servers=()
    
    for server_info in "${dns_servers[@]}"; do
        IFS=':' read -r server name <<< "$server_info"
        
        echo -n -e "${BLUE}Testing $name ($server):${NC} "
        
        # Test ping connectivity
        ping_result="FAIL"
        if ping -c 1 -W 2 "$server" >/dev/null 2>&1; then
            ping_result="OK"
        fi
        
        # Test DNS resolution
        dns_result="FAIL"
        dns_time="N/A"
        if command -v dig >/dev/null 2>&1; then
            start_time=$(date +%s%N)
            if dig @"$server" +short +timeout=2 google.com >/dev/null 2>&1; then
                end_time=$(date +%s%N)
                dns_time=$(( (end_time - start_time) / 1000000 ))
                dns_result="OK"
            fi
        elif command -v nslookup >/dev/null 2>&1; then
            if timeout 2 nslookup google.com "$server" >/dev/null 2>&1; then
                dns_result="OK"
            fi
        fi
        
        # Display results
        if [[ "$ping_result" == "OK" ]] && [[ "$dns_result" == "OK" ]]; then
            echo -e "${GREEN}✓ OK (Ping: $ping_result, DNS: $dns_result, Time: ${dns_time}ms)${NC}"
            successful_servers+=("$server:$name")
        elif [[ "$ping_result" == "OK" ]]; then
            echo -e "${YELLOW}⚠ Partial (Ping: OK, DNS: FAIL)${NC}"
            failed_servers+=("$server:$name:DNS_FAIL")
        else
            echo -e "${RED}✗ FAIL (Unreachable)${NC}"
            failed_servers+=("$server:$name:UNREACHABLE")
        fi
    done
    
    echo ""
    echo -e "${CYAN}═${NC}"
    echo -e "${WHITE}Summary:${NC}"
    echo -e "${GREEN}Successful: ${#successful_servers[@]} servers${NC}"
    echo -e "${RED}Failed: ${#failed_servers[@]} servers${NC}"
    
    if [[ ${#failed_servers[@]} -gt 0 ]]; then
        echo ""
        echo -e "${YELLOW}Failed Servers Details:${NC}"
        for failure in "${failed_servers[@]}"; do
            IFS=':' read -r server name reason <<< "$failure"
            echo -e "  ${RED}• $name ($server): $reason${NC}"
        done
    fi
    
    # Check if all system DNS servers failed
    system_dns_count=$(grep -c "^nameserver" /etc/resolv.conf 2>/dev/null)
    if [[ $system_dns_count -gt 0 ]]; then
        system_failures=0
        for failure in "${failed_servers[@]}"; do
            if [[ "$failure" =~ :System: ]]; then
                ((system_failures++))
            fi
        done
        
        if [[ $system_failures -eq $system_dns_count ]]; then
            echo ""
            echo -e "${RED}⚠ CRITICAL: All system DNS servers are failing!${NC}"
            echo -e "${RED}This will cause email authentication checks to fail.${NC}"
            echo ""
            echo -e "${YELLOW}Recommended actions:${NC}"
            echo -e "  1. Check network connectivity"
            echo -e "  2. Verify firewall rules (port 53 UDP/TCP)"
            echo -e "  3. Consider adding public DNS as backup:"
            echo -e "     echo 'nameserver 8.8.8.8' >> /etc/resolv.conf"
        fi
    fi
    
    pause_for_user
}

diagnose_email_rejection() {
    show_header
    echo -e "${WHITE}Diagnose Email Rejection:${NC}"
    echo ""
    
    echo -e "${YELLOW}This will help diagnose why emails from a domain might be rejected.${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter sender domain (e.g., troycapital.com): ${NC}"
    read domain
    
    if [[ -z "$domain" ]]; then
        echo -e "${RED}Domain cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    domain=$(echo "$domain" | sed 's|^https\?://||' | sed 's|^www\.||' | sed 's|/.*||' | tr '[:upper:]' '[:lower:]')
    
    echo -n -e "${YELLOW}Enter sender email (optional): ${NC}"
    read sender_email
    
    echo ""
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║             Diagnosing: $domain                              ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    issues_found=()
    
    # 1. Check DNS Resolution
    echo -e "${WHITE}Step 1: DNS Resolution${NC}"
    dns_ok=false
    
    if command -v dig >/dev/null 2>&1; then
        # Test with timeout
        a_record=$(timeout 3 dig +short A "$domain" 2>&1 | head -1)
        
        if [[ $? -eq 124 ]]; then
            echo -e "${RED}✗ DNS query timeout${NC}"
            issues_found+=("DNS timeout - server not responding")
        elif [[ -z "$a_record" ]] || [[ "$a_record" =~ "connection timed out" ]]; then
            echo -e "${RED}✗ Domain does not resolve${NC}"
            issues_found+=("Domain DNS resolution failed")
        else
            echo -e "${GREEN}✓ Domain resolves to: $a_record${NC}"
            dns_ok=true
        fi
    fi
    
    # Test DNS server connectivity
    echo -n "  Testing DNS server connectivity: "
    system_dns=$(grep -E "^nameserver" /etc/resolv.conf 2>/dev/null | head -1 | awk '{print $2}')
    if [[ -n "$system_dns" ]]; then
        if ping -c 1 -W 2 "$system_dns" >/dev/null 2>&1; then
            echo -e "${GREEN}✓${NC}"
        else
            echo -e "${RED}✗ Cannot reach DNS server${NC}"
            issues_found+=("DNS server $system_dns unreachable")
        fi
    fi
    echo ""
    
    # 2. Check MX Records
    echo -e "${WHITE}Step 2: MX Records${NC}"
    if $dns_ok && command -v dig >/dev/null 2>&1; then
        mx_records=$(dig +short MX "$domain" 2>&1)
        if [[ -n "$mx_records" ]]; then
            echo -e "${GREEN}✓ MX records found${NC}"
        else
            echo -e "${YELLOW}⚠ No MX records (might use A record fallback)${NC}"
        fi
    else
        echo -e "${YELLOW}⚠ Skipped due to DNS issues${NC}"
    fi
    echo ""
    
    # 3. Check SPF
    echo -e "${WHITE}Step 3: SPF Record${NC}"
    if $dns_ok && command -v dig >/dev/null 2>&1; then
        spf_record=$(dig +short TXT "$domain" 2>&1 | grep "v=spf1" | tr -d '"')
        if [[ -n "$spf_record" ]]; then
            echo -e "${GREEN}✓ SPF record exists${NC}"
            
            # Check if SPF might be blocking
            if [[ "$spf_record" =~ -all ]]; then
                echo -e "  ${YELLOW}Note: Strict SPF (-all) policy${NC}"
            fi
        else
            echo -e "${YELLOW}⚠ No SPF record found${NC}"
            issues_found+=("Missing SPF record")
        fi
    else
        echo -e "${RED}✗ Cannot check - DNS resolution failed${NC}"
        issues_found+=("Cannot verify SPF due to DNS failure")
    fi
    echo ""
    
    # 4. Check DMARC
    echo -e "${WHITE}Step 4: DMARC Policy${NC}"
    if $dns_ok && command -v dig >/dev/null 2>&1; then
        dmarc_record=$(dig +short TXT "_dmarc.$domain" 2>&1 | grep "v=DMARC1" | tr -d '"')
        if [[ -n "$dmarc_record" ]]; then
            echo -e "${GREEN}✓ DMARC record exists${NC}"
            
            if [[ "$dmarc_record" =~ p=reject ]]; then
                echo -e "  ${YELLOW}Note: Strict DMARC (p=reject)${NC}"
            fi
        else
            echo -e "${BLUE}ℹ No DMARC record${NC}"
        fi
    else
        echo -e "${RED}✗ Cannot check - DNS resolution failed${NC}"
    fi
    echo ""
    
    # 5. Check if domain is in SpaCy whitelist
    echo -e "${WHITE}Step 5: SpaCy Whitelist Status${NC}"
    if [[ -f "$BEC_CONFIG" ]]; then
        if jq -e ".whitelisted_domains.authentication_aware[\"$domain\"]" "$BEC_CONFIG" >/dev/null 2>&1; then
            trust_level=$(jq -r ".whitelisted_domains.authentication_aware[\"$domain\"].trust_level // 0" "$BEC_CONFIG" 2>/dev/null)
            echo -e "${GREEN}✓ Domain is whitelisted (Trust Level: $trust_level)${NC}"
        else
            echo -e "${YELLOW}ℹ Domain not in whitelist${NC}"
            echo -e "  Consider adding to whitelist if legitimate"
        fi
    fi
    echo ""
    
    # 6. Check recent logs for errors
    echo -e "${WHITE}Step 6: Recent Log Entries${NC}"
    if [[ -f "/var/log/mail.log" ]]; then
        recent_entries=$(grep -i "$domain" /var/log/mail.log 2>/dev/null | tail -3)
        if [[ -n "$recent_entries" ]]; then
            echo -e "${BLUE}Recent mail log entries:${NC}"
            echo "$recent_entries" | sed 's/^/  /'
        else
            echo -e "${BLUE}No recent log entries found${NC}"
        fi
    fi
    echo ""
    
    # Summary and Recommendations
    echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                     DIAGNOSIS SUMMARY                        ║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
    
    if [[ ${#issues_found[@]} -eq 0 ]]; then
        echo -e "${GREEN}✓ No obvious issues detected${NC}"
        echo ""
        echo -e "${WHITE}If emails are still being rejected:${NC}"
        echo -e "  • Check if sender IP is blacklisted"
        echo -e "  • Verify DKIM signatures are valid"
        echo -e "  • Review SpaCy threshold settings"
        echo -e "  • Check for content-based filtering"
    else
        echo -e "${RED}Issues Found:${NC}"
        for issue in "${issues_found[@]}"; do
            echo -e "  ${RED}• $issue${NC}"
        done
        
        echo ""
        echo -e "${YELLOW}Recommended Actions:${NC}"
        
        for issue in "${issues_found[@]}"; do
            case "$issue" in
                *"DNS timeout"*)
                    echo -e "  1. Check DNS server configuration in /etc/resolv.conf"
                    echo -e "  2. Test alternative DNS servers (8.8.8.8, 1.1.1.1)"
                    echo -e "  3. Check firewall rules for port 53"
                    ;;
                *"DNS resolution failed"*)
                    echo -e "  1. Verify domain exists and is typed correctly"
                    echo -e "  2. Check with: nslookup $domain"
                    ;;
                *"DNS server"*"unreachable"*)
                    echo -e "  1. Check network connectivity"
                    echo -e "  2. Add backup DNS server to /etc/resolv.conf"
                    ;;
                *"SPF"*)
                    echo -e "  1. Domain may need SPF configuration"
                    echo -e "  2. Consider adding to SpaCy whitelist if trusted"
                    ;;
            esac
        done
    fi
    
    echo ""
    echo -e "${BLUE}Need to whitelist this domain?${NC}"
    echo -e "  Use: Main Menu → Option 2 → Add Domain to Whitelist"
    
    pause_for_user
}

# ============================================================================
# EMAIL SEARCH FUNCTIONS
# ============================================================================

search_email_by_sender() {
    show_header
    echo -e "${WHITE}Search Email by Sender:${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter sender email address to search for: ${NC}"
    read sender_email
    
    if [[ -z "$sender_email" ]]; then
        echo -e "${RED}Email address cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Clean email input
    sender_email=$(echo "$sender_email" | tr '[:upper:]' '[:lower:]' | xargs)
    
    echo ""
    echo -e "${BLUE}Searching for emails from: $sender_email${NC}"
    echo -e "${CYAN}================================================================${NC}"
    echo ""
    
    # Search in mail.log
    echo -e "${GREEN}Searching in /var/log/mail.log...${NC}"
    
    # Get matching lines
    matches=$(sudo grep "$sender_email" /var/log/mail.log 2>/dev/null | tail -50)
    
    if [[ -z "$matches" ]]; then
        echo -e "${YELLOW}No emails found from $sender_email in recent logs${NC}"
        
        # Check older logs
        echo ""
        echo -e "${BLUE}Checking older logs...${NC}"
        for logfile in /var/log/mail.log.1 /var/log/mail.log.2.gz; do
            if [[ -f "$logfile" ]]; then
                if [[ "$logfile" == *.gz ]]; then
                    older_matches=$(sudo zgrep "$sender_email" "$logfile" 2>/dev/null | tail -10)
                else
                    older_matches=$(sudo grep "$sender_email" "$logfile" 2>/dev/null | tail -10)
                fi
                
                if [[ -n "$older_matches" ]]; then
                    echo -e "${GREEN}Found in $logfile:${NC}"
                    echo "$older_matches" | tail -5
                    echo "..."
                    break
                fi
            fi
        done
    else
        # Parse and display results
        echo -e "${GREEN}Recent emails from $sender_email:${NC}"
        echo ""
        
        # Extract unique message IDs
        message_ids=$(echo "$matches" | grep -oE '[A-F0-9]{10,12}:' | sed 's/:$//' | sort -u | tail -20)
        
        if [[ -n "$message_ids" ]]; then
            email_count=0
            for msg_id in $message_ids; do
                ((email_count++))
                echo -e "${CYAN}[$email_count] Message ID: $msg_id${NC}"
                
                # Get details for this message
                details=$(sudo grep "$msg_id" /var/log/mail.log 2>/dev/null)
                
                # Extract timestamp
                timestamp=$(echo "$details" | head -1 | awk '{print $1" "$2" "$3}')
                echo -e "  ${WHITE}Time:${NC} $timestamp"
                
                # Extract recipient
                recipient=$(echo "$details" | grep -oE 'to=<[^>]+>' | head -1 | sed 's/to=<//' | sed 's/>//')
                if [[ -n "$recipient" ]]; then
                    echo -e "  ${WHITE}To:${NC} $recipient"
                fi
                
                # Extract subject if available in cleanup line
                subject=$(echo "$details" | grep "message-id=" | head -1)
                if [[ -n "$subject" ]]; then
                    echo -e "  ${WHITE}Message-ID:${NC} $(echo "$subject" | grep -oE 'message-id=<[^>]+>' | sed 's/message-id=//')"
                fi
                
                # Extract status
                status=$(echo "$details" | grep -E 'status=' | tail -1)
                if [[ "$status" == *"status=sent"* ]]; then
                    echo -e "  ${GREEN}Status: Delivered${NC}"
                    relay=$(echo "$status" | grep -oE 'relay=[^,]+' | sed 's/relay=//')
                    if [[ -n "$relay" ]]; then
                        echo -e "  ${WHITE}Via:${NC} $relay"
                    fi
                elif [[ "$status" == *"reject"* ]]; then
                    echo -e "  ${RED}Status: Rejected${NC}"
                    reject_reason=$(echo "$status" | grep -oE 'reject:.*' | head -50)
                    if [[ -n "$reject_reason" ]]; then
                        echo -e "  ${RED}Reason:${NC} $reject_reason"
                    fi
                elif [[ "$status" == *"deferred"* ]]; then
                    echo -e "  ${YELLOW}Status: Deferred${NC}"
                elif [[ "$status" == *"bounced"* ]]; then
                    echo -e "  ${RED}Status: Bounced${NC}"
                else
                    echo -e "  ${WHITE}Status:${NC} Processing or Unknown"
                fi
                
                # Extract size if available
                size=$(echo "$details" | grep -oE 'size=[0-9]+' | head -1 | sed 's/size=//')
                if [[ -n "$size" ]]; then
                    # Convert to human readable
                    if [[ $size -gt 1048576 ]]; then
                        size_mb=$(echo "scale=2; $size / 1048576" | bc)
                        echo -e "  ${WHITE}Size:${NC} ${size_mb}MB"
                    elif [[ $size -gt 1024 ]]; then
                        size_kb=$(echo "scale=2; $size / 1024" | bc)
                        echo -e "  ${WHITE}Size:${NC} ${size_kb}KB"
                    else
                        echo -e "  ${WHITE}Size:${NC} ${size}B"
                    fi
                fi
                
                # Check for SpaCy processing
                spacy_result=$(echo "$details" | grep "delivered via spacyfilter")
                if [[ -n "$spacy_result" ]]; then
                    echo -e "  ${GREEN}✓ Processed by SpaCy filter${NC}"
                fi
                
                echo ""
                
                # Limit display
                if [[ $email_count -ge 10 ]]; then
                    remaining=$(($(echo "$message_ids" | wc -l) - 10))
                    if [[ $remaining -gt 0 ]]; then
                        echo -e "${YELLOW}... and $remaining more emails${NC}"
                    fi
                    break
                fi
            done
        fi
        
        # Summary
        total_count=$(echo "$message_ids" | wc -l)
        echo -e "${CYAN}================================================================${NC}"
        echo -e "${WHITE}Summary:${NC}"
        echo -e "  Total emails found from $sender_email: ${GREEN}$total_count${NC}"
        
        # Check if sender is in any whitelist
        echo ""
        echo -e "${BLUE}Checking whitelists...${NC}"
        
        # Check BEC sender whitelist
        if [[ -f "$BEC_CONFIG" ]]; then
            if grep -q "\"$sender_email\"" "$BEC_CONFIG" 2>/dev/null; then
                echo -e "  ${GREEN}✓ Found in BEC sender whitelist${NC}"
            fi
        fi
        
        # Check domain in BEC domain whitelist
        domain=$(echo "$sender_email" | awk -F@ '{print $2}')
        if [[ -n "$domain" ]] && [[ -f "$BEC_CONFIG" ]]; then
            if grep -q "\"$domain\"" "$BEC_CONFIG" 2>/dev/null; then
                echo -e "  ${GREEN}✓ Domain $domain is in BEC domain whitelist${NC}"
            fi
        fi
    fi
    
    echo ""
    echo -e "${YELLOW}Options:${NC}"
    echo -e "${GREEN}1.${NC} Search for another sender"
    echo -e "${GREEN}2.${NC} View detailed logs for a specific message ID"
    echo -e "${GREEN}3.${NC} Return to main menu"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    read search_choice
    
    case $search_choice in
        1)
            search_email_by_sender
            ;;
        2)
            echo ""
            echo -n -e "${YELLOW}Enter Message ID to view details: ${NC}"
            read msg_id_detail
            if [[ -n "$msg_id_detail" ]]; then
                echo ""
                echo -e "${BLUE}Detailed logs for $msg_id_detail:${NC}"
                sudo grep "$msg_id_detail" /var/log/mail.log 2>/dev/null
            fi
            pause_for_user
            ;;
        3)
            return
            ;;
        *)
            return
            ;;
    esac
}

backup_restore_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Backup & Restore:${NC}"
        echo ""
        echo -e "${GREEN}Configuration Backups:${NC}"
        echo -e "${GREEN}1.${NC} Backup All Configurations"
        echo -e "${GREEN}2.${NC} List Available Backups"
        echo -e "${GREEN}3.${NC} Restore from Backup"
        echo ""
        echo -e "${GREEN}Database Backups:${NC}"
        echo -e "${GREEN}4.${NC} Backup SpaCy Database"
        echo -e "${GREEN}5.${NC} List Database Backups"
        echo -e "${GREEN}6.${NC} Restore Database Backup"
        echo ""
        echo -e "${GREEN}Complete Backup:${NC}"
        echo -e "${GREEN}7.${NC} Full System Backup (Configs + Database)"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-7,9]: ${NC}"

        read choice
        case $choice in
            1) backup_all_configs ;;
            2) list_backups ;;
            3) restore_from_backup ;;
            4) backup_database ;;
            5) list_database_backups ;;
            6) restore_database_backup ;;
            7) full_system_backup ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

backup_all_configs() {
    show_header
    echo -e "${WHITE}Backup All Configurations:${NC}"
    echo ""

    echo -n -e "${YELLOW}Enter backup description: ${NC}"
    read description

    if [[ -z "$description" ]]; then
        description="Complete backup via OpenSpaCy menu"
    fi

    echo ""
    echo -e "${BLUE}Creating comprehensive backup...${NC}"
    
    timestamp=$(date +%Y%m%d_%H%M%S)
    backup_files=()

    for config_file in "$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG"; do
        if [[ -f "$config_file" ]]; then
            create_backup "$config_file" "$description"
            basename_file=$(basename "$config_file")
            backup_files+=("$BACKUP_DIR/${basename_file}.backup.$timestamp")
        fi
    done

    echo ""
    echo -e "${GREEN}✓ All configurations backed up successfully!${NC}"
    
    # Copy to SDNAS1 backup location
    echo ""
    echo -e "${BLUE}Copying backups to SDNAS1...${NC}"
    sdnas_dir="/home/admin/backups/spacy_files"
    
    # Create directory if it doesn't exist
    if [[ ! -d "$sdnas_dir" ]]; then
        mkdir -p "$sdnas_dir" 2>/dev/null
    fi
    
    # Copy each backup file
    if [[ -d "$sdnas_dir" ]]; then
        copy_success=0
        copy_failed=0
        for backup_file in "${backup_files[@]}"; do
            if [[ -f "$backup_file" ]]; then
                if cp "$backup_file" "$sdnas_dir/" 2>/dev/null; then
                    ((copy_success++))
                else
                    ((copy_failed++))
                fi
            fi
        done
        
        if [[ $copy_success -gt 0 ]]; then
            echo -e "   ${GREEN}✓${NC} $copy_success config backups copied to SDNAS1"
            echo -e "${CYAN}SDNAS1 backup location: $sdnas_dir${NC}"
        fi
        
        if [[ $copy_failed -gt 0 ]]; then
            echo -e "   ${YELLOW}⚠${NC} $copy_failed files could not be copied (check permissions)"
        fi
    else
        echo -e "   ${YELLOW}⚠${NC} SDNAS1 directory not accessible: $sdnas_dir"
    fi
    
    pause_for_user
}

list_backups() {
    show_header
    echo -e "${WHITE}Available Backups:${NC}"
    echo ""

    if [[ ! -d "$BACKUP_DIR" ]]; then
        echo -e "${RED}Backup directory not found.${NC}"
        pause_for_user
        return
    fi

    backup_files=$(find "$BACKUP_DIR" -name "*.backup.*" 2>/dev/null | sort -r)

    if [[ -z "$backup_files" ]]; then
        echo -e "${YELLOW}No backup files found.${NC}"
    else
        echo -e "${GREEN}Recent backups (20 most recent):${NC}"
        echo ""
        echo "$backup_files" | head -20 | while read -r backup_file; do
            filename=$(basename "$backup_file")
            file_date=$(stat -c %y "$backup_file" 2>/dev/null | cut -d' ' -f1-2)
            file_size=$(stat -c %s "$backup_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
            echo -e "${BLUE}$filename${NC}"
            echo -e "  Date: $file_date, Size: $file_size"
            echo ""
        done
    fi

    pause_for_user
}

restore_from_backup() {
    show_header
    echo -e "${WHITE}Restore from Backup:${NC}"
    echo ""
    echo -e "${RED}⚠️  WARNING: This will overwrite current configuration!${NC}"
    echo ""

    backup_files=$(find "$BACKUP_DIR" -name "*.backup.*" 2>/dev/null | sort -r)

    if [[ -z "$backup_files" ]]; then
        echo -e "${YELLOW}No backup files found.${NC}"
        pause_for_user
        return
    fi

    echo -e "${GREEN}Available backups:${NC}"
    echo ""
    echo "$backup_files" | head -10 | nl

    echo ""
    echo -n -e "${YELLOW}Enter backup number to restore (1-10): ${NC}"
    read backup_num

    if [[ ! "$backup_num" =~ ^[1-9][0-9]*$ ]] || [[ "$backup_num" -gt 10 ]]; then
        echo -e "${RED}Invalid backup number.${NC}"
        pause_for_user
        return
    fi

    selected_backup=$(echo "$backup_files" | sed -n "${backup_num}p")

    if [[ -z "$selected_backup" ]]; then
        echo -e "${RED}Backup file not found.${NC}"
        pause_for_user
        return
    fi

    echo ""
    echo -e "${YELLOW}Selected: $(basename "$selected_backup")${NC}"
    echo -n -e "${YELLOW}Restore this backup? [y/N]: ${NC}"
    read confirm

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        pause_for_user
        return
    fi

    # Determine target file
    if [[ "$selected_backup" == *"bec_config"* ]]; then
        target_file="$BEC_CONFIG"
    elif [[ "$selected_backup" == *"module_config"* ]]; then
        target_file="$MODULE_CONFIG"
    elif [[ "$selected_backup" == *"filter_config"* ]]; then
        target_file="$FILTER_CONFIG"
    elif [[ "$selected_backup" == *"auth_config"* ]]; then
        target_file="$AUTH_CONFIG"
    elif [[ "$selected_backup" == *"threshold_config"* ]]; then
        target_file="$THRESHOLD_CONFIG"
    else
        echo -e "${RED}Cannot determine target file.${NC}"
        pause_for_user
        return
    fi

    create_backup "$target_file" "Before restore operation"

    if cp "$selected_backup" "$target_file"; then
        fix_permissions "$target_file"
        echo -e "${GREEN}✓${NC} Configuration restored successfully!"
    else
        echo -e "${RED}✗${NC} Failed to restore configuration!"
    fi

    pause_for_user
}

system_info() {
    show_header
    echo -e "${WHITE}System Information:${NC}"
    echo ""
    
    echo -e "${GREEN}System Overview:${NC}"
    echo -e "${BLUE}  Hostname:${NC} $(hostname)"
    echo -e "${BLUE}  IP Address:${NC} $(hostname -I | awk '{print $1}')"
    echo -e "${BLUE}  System Uptime:${NC} $(uptime -p)"
    echo -e "${BLUE}  Current Time:${NC} $(date '+%Y-%m-%d %H:%M:%S %Z')"
    echo ""
    
    echo -e "${GREEN}SpaCy Configuration:${NC}"
    echo -e "${BLUE}  Root Directory:${NC} $SPACY_ROOT"
    echo -e "${BLUE}  BEC Config:${NC} $BEC_CONFIG"
    echo -e "${BLUE}  Module Config:${NC} $MODULE_CONFIG"
    echo ""

    echo -e "${GREEN}Configuration Status:${NC}"
    for config_file in "$BEC_CONFIG" "$MODULE_CONFIG" "$FILTER_CONFIG" "$AUTH_CONFIG" "$THRESHOLD_CONFIG" "$TRUSTED_DOMAINS_CONFIG"; do
        config_name=$(basename "$config_file")
        if [[ -f "$config_file" ]]; then
            file_size=$(stat -c %s "$config_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
            echo -e "${GREEN}✓${NC} $config_name: Found (${file_size})"
            # Check JSON validity
            if ! jq '.' "$config_file" >/dev/null 2>&1; then
                echo -e "  ${RED}⚠ Has JSON errors${NC}"
            fi
        else
            echo -e "${YELLOW}!${NC} $config_name: Not found"
        fi
    done
    echo ""

    echo -e "${GREEN}Service Status:${NC}"
    # Postfix
    if systemctl is-active --quiet postfix; then
        echo -e "${GREEN}✓${NC} Postfix: Running"
        if command -v postqueue >/dev/null 2>&1; then
            queue_count=$(postqueue -p 2>/dev/null | tail -1 | grep -o '[0-9]*' || echo "0")
            echo -e "  ${BLUE}Mail Queue:${NC} $queue_count messages"
        fi
    else
        echo -e "${RED}✗${NC} Postfix: Not running"
    fi
    
    # SpaCy DB Processor
    if systemctl is-active --quiet spacy-db-processor; then
        echo -e "${GREEN}✓${NC} SpaCy DB Processor: Running"
    else
        echo -e "${RED}✗${NC} SpaCy DB Processor: Not running"
    fi
    
    # SpaCy Web
    if systemctl is-active --quiet spacyweb; then
        echo -e "${GREEN}✓${NC} SpaCy Web Interface: Running (port 5500)"
    else
        echo -e "${YELLOW}!${NC} SpaCy Web Interface: Not running"
    fi
    
    # Redis
    if systemctl is-active --quiet redis-server; then
        echo -e "${GREEN}✓${NC} Redis: Running"
        redis_queue_size=$(redis-cli LLEN email_queue 2>/dev/null || echo "N/A")
        echo -e "  ${BLUE}Email Queue Size:${NC} $redis_queue_size"
    else
        echo -e "${YELLOW}!${NC} Redis: Not running"
    fi
    echo ""

    echo -e "${GREEN}Database Status:${NC}"
    # Check database connectivity and stats
    db_stats=$(mysql -e "SELECT 
        (SELECT COUNT(*) FROM email_analysis) as total_emails,
        (SELECT COUNT(*) FROM email_analysis WHERE DATE(timestamp) = CURDATE()) as today_emails,
        (SELECT COUNT(*) FROM email_analysis WHERE spam_score > 5) as blocked_emails,
        (SELECT ROUND(AVG(spam_score), 2) FROM email_analysis WHERE timestamp > DATE_SUB(NOW(), INTERVAL 7 DAY)) as avg_spam_7d
        FROM dual;" $DB_NAME 2>/dev/null | tail -1)
    
    if [[ -n "$db_stats" ]]; then
        IFS=$'\t' read -r total_emails today_emails blocked_emails avg_spam <<< "$db_stats"
        echo -e "${BLUE}  Total Emails Analyzed:${NC} ${total_emails:-0}"
        echo -e "${BLUE}  Emails Today:${NC} ${today_emails:-0}"
        echo -e "${BLUE}  High-Risk Blocked:${NC} ${blocked_emails:-0}"
        echo -e "${BLUE}  7-Day Avg Spam Score:${NC} ${avg_spam:-N/A}"
    else
        echo -e "${YELLOW}  Database connection unavailable${NC}"
    fi
    echo ""

    echo -e "${GREEN}Python Dependencies:${NC}"
    $PYTHON -c "
import sys
modules = [
    ('spf', 'SPF'),
    ('dkim', 'DKIM'),
    ('dns.resolver', 'DNS/DMARC'),
    ('email_validator', 'Email Validation'),
    ('redis', 'Redis Client'),
    ('sqlalchemy', 'SQLAlchemy'),
    ('spacy', 'SpaCy NLP')
]
for module, name in modules:
    try:
        __import__(module)
        print(f'  ✓ {name}: Available')
    except ImportError:
        print(f'  ✗ {name}: Missing')
" 2>/dev/null
    echo ""

    echo -e "${GREEN}Backup Status:${NC}"
    if [[ -d "$BACKUP_DIR" ]]; then
        backup_count=$(find "$BACKUP_DIR" -name "*.backup.*" 2>/dev/null | wc -l)
        latest_backup=$(find "$BACKUP_DIR" -name "*.backup.*" -o -name "*.tar.gz" 2>/dev/null | xargs ls -t 2>/dev/null | head -1)
        echo -e "${BLUE}  Local Backup Directory:${NC} $BACKUP_DIR"
        echo -e "${BLUE}  Available Backups:${NC} $backup_count files"
        if [[ -n "$latest_backup" ]]; then
            backup_date=$(stat -c %y "$latest_backup" 2>/dev/null | cut -d' ' -f1)
            echo -e "${BLUE}  Latest Backup:${NC} $backup_date"
        fi
    else
        echo -e "${YELLOW}  Backup Directory:${NC} Not found"
    fi
    
    # Check SDNAS1 backup
    sdnas_dir="/home/admin/backups/spacy_files"
    if [[ -d "$sdnas_dir" ]]; then
        sdnas_count=$(find "$sdnas_dir" -type f 2>/dev/null | wc -l)
        echo -e "${BLUE}  SDNAS1 Backup:${NC} Connected ($sdnas_count files)"
    else
        echo -e "${YELLOW}  SDNAS1 Backup:${NC} Not mounted"
    fi
    echo ""

    echo -e "${GREEN}Log Files:${NC}"
    for log_file in "/var/log/mail.log" "$LOG_DIR/email_filter_error.log" "$LOG_DIR/db_processor.log"; do
        if [[ -f "$log_file" ]]; then
            log_size=$(stat -c %s "$log_file" 2>/dev/null | numfmt --to=iec 2>/dev/null || echo "unknown")
            log_name=$(basename "$log_file")
            echo -e "${BLUE}  $log_name:${NC} $log_size"
        fi
    done

    pause_for_user
}

# ============================================================================
# SEARCH FUNCTIONS FOR BEC WHITELISTS
# ============================================================================

search_bec_sender_whitelist() {
    show_header
    echo -e "${WHITE}Search/Filter BEC Sender Whitelist:${NC}"
    echo ""
    
    if [[ ! -f "$BEC_CONFIG" ]]; then
        echo -e "${RED}BEC configuration file not found.${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${YELLOW}Enter sender email or domain to search for:${NC}"
    echo -e "${BLUE}(e.g., 'john@example.com' or just 'example.com' or 'john')${NC}"
    echo ""
    echo -n -e "${YELLOW}Search: ${NC}"
    read search_term
    
    if [[ -z "$search_term" ]]; then
        echo -e "${RED}Search term cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Convert to lowercase for case-insensitive search
    search_term_lower=$(echo "$search_term" | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Searching for: '$search_term'${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Search in whitelist.senders (legacy)
    echo -e "${GREEN}Whitelisted Senders (Legacy):${NC}"
    found_senders=$(jq -r ".whitelist.senders | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)

    legacy_count=0
    if [[ -n "$found_senders" ]]; then
        while IFS= read -r sender; do
            # Get sender details
            trust_level=$(jq -r ".whitelist.senders.\"$sender\".trust_level // 3" "$BEC_CONFIG" 2>/dev/null)
            description=$(jq -r ".whitelist.senders.\"$sender\".description // \"\"" "$BEC_CONFIG" 2>/dev/null)
            auth_req=$(jq -r ".whitelist.senders.\"$sender\".require_auth[]? // \"\"" "$BEC_CONFIG" 2>/dev/null | tr '\n' ',' | sed 's/,$//')

            echo -e "  ${CYAN}• ${WHITE}$sender${NC}"
            echo -e "    Trust Level: ${YELLOW}$trust_level${NC}"
            [[ -n "$description" ]] && echo -e "    Description: ${BLUE}$description${NC}"
            [[ -n "$auth_req" ]] && echo -e "    Required Auth: ${MAGENTA}$auth_req${NC}"
            echo ""
            ((legacy_count++))
        done <<< "$found_senders"
    else
        echo -e "${YELLOW}  No legacy senders found${NC}"
        echo ""
    fi

    # Search in whitelist.authentication_aware.senders (current)
    echo -e "${GREEN}Whitelisted Senders (Authentication-Aware):${NC}"
    auth_aware_senders=$(jq -r ".whitelist.authentication_aware.senders | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)

    auth_count=0
    if [[ -n "$auth_aware_senders" ]]; then
        while IFS= read -r sender; do
            # Get sender details
            trust_bonus=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".trust_score_bonus // 0" "$BEC_CONFIG" 2>/dev/null)
            description=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".description // \"\"" "$BEC_CONFIG" 2>/dev/null)
            auth_req=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".require_auth[]? // \"\"" "$BEC_CONFIG" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            for_domain=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".for_domain // \"all\"" "$BEC_CONFIG" 2>/dev/null)
            bypass_fin=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".bypass_financial_checks // false" "$BEC_CONFIG" 2>/dev/null)

            echo -e "  ${CYAN}• ${WHITE}$sender${NC}"
            echo -e "    Trust Bonus: ${YELLOW}-$trust_bonus points${NC}"
            [[ -n "$description" ]] && echo -e "    Description: ${BLUE}$description${NC}"
            [[ -n "$auth_req" ]] && echo -e "    Required Auth: ${MAGENTA}$auth_req${NC}"
            echo -e "    For Domain: ${GREEN}$for_domain${NC}"
            [[ "$bypass_fin" == "true" ]] && echo -e "    ${YELLOW}⚠ Bypasses financial checks${NC}"
            echo ""
            ((auth_count++))
        done <<< "$auth_aware_senders"
    else
        echo -e "${YELLOW}  No authentication-aware senders found${NC}"
        echo ""
    fi

    # Count total results
    total_count=$((legacy_count + auth_count))
    if [[ $total_count -gt 0 ]]; then
        echo -e "${BLUE}Found $total_count sender(s) matching '$search_term' (Legacy: $legacy_count, Auth-Aware: $auth_count)${NC}"

        # Offer to remove
        echo ""
        echo -e "${YELLOW}Would you like to:${NC}"
        echo -e "${GREEN}1.${NC} Remove one of these senders"
        echo -e "${GREEN}2.${NC} Keep all and return to menu"
        echo ""
        echo -n -e "${YELLOW}Select [1-2]: ${NC}"
        read action_choice

        if [[ "$action_choice" == "1" ]]; then
            echo ""
            echo -n -e "${YELLOW}Enter the exact sender email to remove: ${NC}"
            read sender_to_remove

            # Try legacy location first
            if jq -e ".whitelist.senders.\"$sender_to_remove\"" "$BEC_CONFIG" >/dev/null 2>&1; then
                echo -n -e "${RED}Remove '$sender_to_remove' from whitelist? (y/n): ${NC}"
                read confirm

                if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                    create_backup "$BEC_CONFIG" "Before removing $sender_to_remove"
                    jq "del(.whitelist.senders.\"$sender_to_remove\")" "$BEC_CONFIG" > /tmp/bec_temp.json
                    mv /tmp/bec_temp.json "$BEC_CONFIG"
                    echo -e "${GREEN}✓ Removed '$sender_to_remove' from whitelist${NC}"
                fi
            # Try authentication_aware location
            elif jq -e ".whitelist.authentication_aware.senders.\"$sender_to_remove\"" "$BEC_CONFIG" >/dev/null 2>&1; then
                echo -n -e "${RED}Remove '$sender_to_remove' from whitelist? (y/n): ${NC}"
                read confirm

                if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                    create_backup "$BEC_CONFIG" "Before removing $sender_to_remove"
                    jq "del(.whitelist.authentication_aware.senders.\"$sender_to_remove\")" "$BEC_CONFIG" > /tmp/bec_temp.json
                    mv /tmp/bec_temp.json "$BEC_CONFIG"
                    echo -e "${GREEN}✓ Removed '$sender_to_remove' from whitelist${NC}"
                fi
            else
                echo -e "${RED}Sender not found in whitelist${NC}"
            fi
        fi
    else
        echo -e "${YELLOW}No senders found matching '$search_term'${NC}"
    fi
    
    pause_for_user
}

search_bec_domain_whitelist() {
    show_header
    echo -e "${WHITE}Search/Filter BEC Domain Whitelist:${NC}"
    echo ""
    
    if [[ ! -f "$BEC_CONFIG" ]]; then
        echo -e "${RED}BEC configuration file not found.${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${YELLOW}Enter domain to search for:${NC}"
    echo -e "${BLUE}(e.g., 'example.com' or partial like 'example')${NC}"
    echo ""
    echo -n -e "${YELLOW}Search: ${NC}"
    read search_term
    
    if [[ -z "$search_term" ]]; then
        echo -e "${RED}Search term cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    # Convert to lowercase for case-insensitive search
    search_term_lower=$(echo "$search_term" | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Searching for: '$search_term'${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    found_any=false
    
    # Search in whitelisted_domains.authentication_aware
    domains=$(jq -r ".whitelisted_domains.authentication_aware | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)
    
    if [[ -n "$domains" ]]; then
        found_any=true
        echo -e "${GREEN}Whitelisted Domains (Authentication Required):${NC}"
        
        while IFS= read -r domain; do
            # Get domain details
            trust_level=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain\".trust_level // 3" "$BEC_CONFIG" 2>/dev/null)
            description=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain\".description // \"\"" "$BEC_CONFIG" 2>/dev/null)
            auth_req=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain\".require_auth[]? // \"\"" "$BEC_CONFIG" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            bypass_fin=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain\".bypass_financial_checks // false" "$BEC_CONFIG" 2>/dev/null)
            
            echo -e "  ${CYAN}• ${WHITE}$domain${NC} (Trust Level: $trust_level)"
            [[ -n "$description" ]] && echo -e "    Description: ${BLUE}$description${NC}"
            [[ -n "$auth_req" ]] && echo -e "    Required Auth: ${MAGENTA}$auth_req${NC}"
            [[ "$bypass_fin" == "true" ]] && echo -e "    ${YELLOW}⚠ Bypasses financial checks${NC}"
            echo ""
        done <<< "$domains"
    fi
    
    # Also search in bulk sender exceptions
    bulk_domains=$(jq -r ".whitelist.bulk_sender_exceptions[] | select(. | ascii_downcase | contains(\"$search_term_lower\"))" "$BEC_CONFIG" 2>/dev/null)
    if [[ -n "$bulk_domains" ]]; then
        found_any=true
        echo -e "${MAGENTA}Bulk Sender Exceptions:${NC}"
        while IFS= read -r domain; do
            echo -e "  ${CYAN}• ${WHITE}$domain${NC}"
        done <<< "$bulk_domains"
        echo ""
    fi
    
    if [[ "$found_any" == "true" ]]; then
        # Offer to remove
        echo ""
        echo -e "${YELLOW}Would you like to:${NC}"
        echo -e "${GREEN}1.${NC} Remove one of these domains"
        echo -e "${GREEN}2.${NC} Modify trust level of a domain"
        echo -e "${GREEN}3.${NC} Keep all and return to menu"
        echo ""
        echo -n -e "${YELLOW}Select [1-3]: ${NC}"
        read action_choice
        
        case $action_choice in
            1)
                echo ""
                echo -n -e "${YELLOW}Enter the exact domain to remove: ${NC}"
                read domain_to_remove
                
                # Check in whitelisted_domains.authentication_aware
                if jq -e ".whitelisted_domains.authentication_aware.\"$domain_to_remove\"" "$BEC_CONFIG" >/dev/null 2>&1; then
                    trust_level=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain_to_remove\".trust_level // 3" "$BEC_CONFIG" 2>/dev/null)
                    echo -n -e "${RED}Remove '$domain_to_remove' from whitelist (trust level $trust_level)? (y/n): ${NC}"
                    read confirm
                    
                    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                        create_backup "$BEC_CONFIG" "Before removing $domain_to_remove"
                        jq "del(.whitelisted_domains.authentication_aware.\"$domain_to_remove\")" "$BEC_CONFIG" > /tmp/bec_temp.json
                        mv /tmp/bec_temp.json "$BEC_CONFIG"
                        echo -e "${GREEN}✓ Removed '$domain_to_remove' from whitelist${NC}"
                    fi
                else
                    echo -e "${RED}Domain not found in whitelist${NC}"
                fi
                
                # Check bulk sender exceptions
                if jq -e ".whitelist.bulk_sender_exceptions[] | select(. == \"$domain_to_remove\")" "$BEC_CONFIG" >/dev/null 2>&1; then
                    echo -n -e "${RED}Remove '$domain_to_remove' from bulk sender exceptions? (y/n): ${NC}"
                    read confirm
                    
                    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                        create_backup "$BEC_CONFIG" "Before removing $domain_to_remove from bulk"
                        jq ".whitelist.bulk_sender_exceptions -= [\"$domain_to_remove\"]" "$BEC_CONFIG" > /tmp/bec_temp.json
                        mv /tmp/bec_temp.json "$BEC_CONFIG"
                        echo -e "${GREEN}✓ Removed '$domain_to_remove' from bulk sender exceptions${NC}"
                    fi
                fi
                ;;
            2)
                modify_domain_trust_level
                ;;
        esac
    else
        echo -e "${YELLOW}No domains found matching '$search_term'${NC}"
        echo ""
        echo -n -e "${YELLOW}Would you like to add '$search_term' to the whitelist? (y/n): ${NC}"
        read add_choice
        
        if [[ "$add_choice" == "y" || "$add_choice" == "Y" ]]; then
            # Redirect to add function with pre-filled domain
            echo "$search_term" > /tmp/domain_prefill.txt
            add_bec_domain_whitelist
        fi
    fi
    
    pause_for_user
}

# ============================================================================
# UNIFIED SEARCH ACROSS ALL WHITELISTS
# ============================================================================

unified_whitelist_search() {
    show_header
    echo -e "${WHITE}Unified Whitelist Search:${NC}"
    echo ""
    
    echo -e "${YELLOW}This searches across:${NC}"
    echo -e "  • BEC sender whitelist"
    echo -e "  • BEC domain whitelist (all trust levels)"
    echo -e "  • Trusted domains (fast-track)"
    echo -e "  • Bulk sender exceptions"
    echo ""
    
    echo -n -e "${YELLOW}Enter search term: ${NC}"
    read search_term
    
    if [[ -z "$search_term" ]]; then
        echo -e "${RED}Search term cannot be empty.${NC}"
        pause_for_user
        return
    fi
    
    search_term_lower=$(echo "$search_term" | tr '[:upper:]' '[:lower:]')
    
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Searching all whitelists for: '$search_term'${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Search BEC senders (both old and new format)
    echo -e "${GREEN}=== BEC Sender Whitelist ===${NC}"
    # Search in old location (.whitelist.senders)
    found_senders=$(jq -r ".whitelist.senders | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)
    # Also search in new location (.whitelist.authentication_aware.senders)
    auth_aware_senders=$(jq -r ".whitelist.authentication_aware.senders | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)

    all_senders=$(echo -e "$found_senders\n$auth_aware_senders" | sort -u | grep -v '^$')

    if [[ -n "$all_senders" ]]; then
        while IFS= read -r sender; do
            # Try both locations for trust level
            trust_level=$(jq -r ".whitelist.senders.\"$sender\".trust_level // .whitelist.authentication_aware.senders.\"$sender\".trust_score_bonus // 3" "$BEC_CONFIG" 2>/dev/null)
            # Check for auth requirements
            auth_req=$(jq -r ".whitelist.authentication_aware.senders.\"$sender\".require_auth[]? // empty" "$BEC_CONFIG" 2>/dev/null | tr '\n' ',' | sed 's/,$//')
            if [[ -n "$auth_req" ]]; then
                echo -e "  ${CYAN}• ${WHITE}$sender${NC} (Trust: $trust_level, Auth: $auth_req)"
            else
                echo -e "  ${CYAN}• ${WHITE}$sender${NC} (Trust: $trust_level)"
            fi
        done <<< "$all_senders"
    else
        echo -e "  ${YELLOW}No matches${NC}"
    fi
    echo ""
    
    # Search BEC domains
    echo -e "${GREEN}=== BEC Domain Whitelist ===${NC}"
    found_domains=false
    
    # Search in whitelisted_domains.authentication_aware
    domains=$(jq -r ".whitelisted_domains.authentication_aware | to_entries[] | select(.key | ascii_downcase | contains(\"$search_term_lower\")) | .key" "$BEC_CONFIG" 2>/dev/null)
    if [[ -n "$domains" ]]; then
        found_domains=true
        while IFS= read -r domain; do
            trust_level=$(jq -r ".whitelisted_domains.authentication_aware.\"$domain\".trust_level // 3" "$BEC_CONFIG" 2>/dev/null)
            echo -e "  ${CYAN}• ${WHITE}$domain${NC} (Trust Level: $trust_level)"
        done <<< "$domains"
    fi
    
    [[ "$found_domains" == "false" ]] && echo -e "  ${YELLOW}No matches${NC}"
    echo ""
    
    # Search trusted domains (fast-track)
    if [[ -f "$TRUSTED_DOMAINS_CONFIG" ]]; then
        echo -e "${GREEN}=== Trusted Domains (Fast-track) ===${NC}"
        trusted=$(jq -r ".trusted_domains[] | select(. | ascii_downcase | contains(\"$search_term_lower\"))" "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null)
        if [[ -n "$trusted" ]]; then
            while IFS= read -r domain; do
                echo -e "  ${CYAN}• ${WHITE}$domain${NC} ${YELLOW}(bypasses most checks)${NC}"
            done <<< "$trusted"
        else
            echo -e "  ${YELLOW}No matches${NC}"
        fi
        echo ""
    fi
    
    # Search bulk sender exceptions
    echo -e "${GREEN}=== Bulk Sender Exceptions ===${NC}"
    bulk=$(jq -r ".whitelist.bulk_sender_exceptions[] | select(. | ascii_downcase | contains(\"$search_term_lower\"))" "$BEC_CONFIG" 2>/dev/null)
    if [[ -n "$bulk" ]]; then
        while IFS= read -r domain; do
            echo -e "  ${CYAN}• ${WHITE}$domain${NC}"
        done <<< "$bulk"
    else
        echo -e "  ${YELLOW}No matches${NC}"
    fi
    
    pause_for_user
}

# ============================================================================
# TRUSTED DOMAINS MANAGEMENT
# ============================================================================

trusted_domains_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Trusted Domains Management (Fast-track Whitelist):${NC}"
        echo ""
        echo -e "${YELLOW}Note: Trusted domains receive minimal security analysis${NC}"
        echo -e "${YELLOW}      They bypass BEC, typosquatting, and marketing filters${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} View Current Trusted Domains"
        echo -e "${GREEN}2.${NC} Add Trusted Domain"
        echo -e "${GREEN}3.${NC} Remove Trusted Domain"
        echo -e "${GREEN}4.${NC} View Configuration Details"
        echo -e "${GREEN}5.${NC} Restore Gmail/Google Trust (NOT Recommended)"
        echo -e "${GREEN}6.${NC} Backup Current Configuration"
        echo ""
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-6,9]: ${NC}"
        
        read choice
        case $choice in
            1) view_trusted_domains ;;
            2) add_trusted_domain ;;
            3) remove_trusted_domain ;;
            4) view_trusted_config ;;
            5) restore_gmail_trust ;;
            6) backup_trusted_config ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

view_trusted_domains() {
    show_header
    echo -e "${WHITE}Current Trusted Domains:${NC}"
    echo ""
    
    if [[ ! -f "$TRUSTED_DOMAINS_CONFIG" ]]; then
        echo -e "${RED}Configuration file not found at: $TRUSTED_DOMAINS_CONFIG${NC}"
        pause_for_user
        return
    fi
    
    # Extract trusted domains
    domains=$(jq -r '.trusted_domains[]' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null | sort)
    
    if [[ -z "$domains" ]]; then
        echo -e "${YELLOW}No trusted domains configured${NC}"
    else
        echo -e "${GREEN}Domains with fast-track processing:${NC}"
        echo ""
        while IFS= read -r domain; do
            # Check if there's a note for this domain
            note=$(jq -r ".trusted_domains_notes.\"$domain\" // \"\"" "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null)
            if [[ -n "$note" ]]; then
                echo -e "  ${CYAN}• ${WHITE}$domain${NC} - ${BLUE}$note${NC}"
            else
                echo -e "  ${CYAN}• ${WHITE}$domain${NC}"
            fi
        done <<< "$domains"
        
        echo ""
        count=$(echo "$domains" | wc -l)
        echo -e "${BLUE}Total: $count trusted domains${NC}"
    fi
    
    # Show configuration status
    echo ""
    echo -e "${WHITE}Configuration Settings:${NC}"
    fast_track=$(jq -r '.configuration.fast_track_enabled // true' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null)
    spam_bonus=$(jq -r '.configuration.spam_score_bonus // -3.0' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null)
    
    if [[ "$fast_track" == "true" ]]; then
        echo -e "  ${GREEN}✓${NC} Fast-track processing: Enabled"
    else
        echo -e "  ${YELLOW}⚠${NC} Fast-track processing: Disabled"
    fi
    echo -e "  ${BLUE}•${NC} Spam score bonus: $spam_bonus points"
    
    pause_for_user
}

add_trusted_domain() {
    show_header
    echo -e "${WHITE}Add Trusted Domain:${NC}"
    echo ""
    echo -e "${YELLOW}WARNING: Only add domains you completely trust!${NC}"
    echo -e "${YELLOW}         These domains will bypass most security checks.${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter domain to trust (e.g., example.com): ${NC}"
    read new_domain
    
    if [[ -z "$new_domain" ]]; then
        echo -e "${RED}Domain cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    # Clean domain
    new_domain=$(echo "$new_domain" | tr '[:upper:]' '[:lower:]' | sed 's/^www\.//')
    
    # Check if already exists
    if jq -e ".trusted_domains[] | select(. == \"$new_domain\")" "$TRUSTED_DOMAINS_CONFIG" >/dev/null 2>&1; then
        echo -e "${YELLOW}Domain '$new_domain' is already trusted${NC}"
        pause_for_user
        return
    fi
    
    echo -n -e "${YELLOW}Enter description/reason (optional): ${NC}"
    read description
    
    # Backup before modifying
    create_backup "$TRUSTED_DOMAINS_CONFIG" "Before adding $new_domain"
    
    # Add to trusted domains
    jq ".trusted_domains += [\"$new_domain\"]" "$TRUSTED_DOMAINS_CONFIG" > /tmp/trusted_temp.json
    
    # Add description if provided
    if [[ -n "$description" ]]; then
        jq ".trusted_domains_notes.\"$new_domain\" = \"$description\"" /tmp/trusted_temp.json > /tmp/trusted_temp2.json
        mv /tmp/trusted_temp2.json /tmp/trusted_temp.json
    fi
    
    mv /tmp/trusted_temp.json "$TRUSTED_DOMAINS_CONFIG"
    
    echo ""
    echo -e "${GREEN}✓ Added '$new_domain' to trusted domains${NC}"
    echo -e "${YELLOW}Note: Restart postfix for changes to take effect${NC}"
    echo ""
    echo -n -e "${YELLOW}Restart postfix now? (y/n): ${NC}"
    read restart_choice
    
    if [[ "$restart_choice" == "y" || "$restart_choice" == "Y" ]]; then
        systemctl restart postfix
        echo -e "${GREEN}✓ Postfix restarted${NC}"
    fi
    
    pause_for_user
}

remove_trusted_domain() {
    show_header
    echo -e "${WHITE}Remove Trusted Domain:${NC}"
    echo ""
    
    # Get current domains
    domains=$(jq -r '.trusted_domains[]' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null | sort)
    
    if [[ -z "$domains" ]]; then
        echo -e "${YELLOW}No trusted domains to remove${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Current trusted domains:${NC}"
    echo ""
    i=1
    declare -A domain_map
    while IFS= read -r domain; do
        echo -e "  ${GREEN}$i.${NC} $domain"
        domain_map[$i]=$domain
        ((i++))
    done <<< "$domains"
    
    echo ""
    echo -n -e "${YELLOW}Select domain to remove [1-$((i-1))]: ${NC}"
    read choice
    
    if [[ -z "${domain_map[$choice]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        pause_for_user
        return
    fi
    
    domain_to_remove="${domain_map[$choice]}"
    
    echo ""
    echo -n -e "${YELLOW}Remove '$domain_to_remove' from trusted domains? (y/n): ${NC}"
    read confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        pause_for_user
        return
    fi
    
    # Backup before modifying
    create_backup "$TRUSTED_DOMAINS_CONFIG" "Before removing $domain_to_remove"
    
    # Remove from trusted domains
    jq "del(.trusted_domains[] | select(. == \"$domain_to_remove\")) | del(.trusted_domains_notes.\"$domain_to_remove\")" "$TRUSTED_DOMAINS_CONFIG" > /tmp/trusted_temp.json
    mv /tmp/trusted_temp.json "$TRUSTED_DOMAINS_CONFIG"
    
    echo ""
    echo -e "${GREEN}✓ Removed '$domain_to_remove' from trusted domains${NC}"
    echo -e "${YELLOW}Note: Restart postfix for changes to take effect${NC}"
    echo ""
    echo -n -e "${YELLOW}Restart postfix now? (y/n): ${NC}"
    read restart_choice
    
    if [[ "$restart_choice" == "y" || "$restart_choice" == "Y" ]]; then
        systemctl restart postfix
        echo -e "${GREEN}✓ Postfix restarted${NC}"
    fi
    
    pause_for_user
}

view_trusted_config() {
    show_header
    echo -e "${WHITE}Trusted Domains Configuration Details:${NC}"
    echo ""
    
    if [[ ! -f "$TRUSTED_DOMAINS_CONFIG" ]]; then
        echo -e "${RED}Configuration file not found${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Configuration File:${NC} $TRUSTED_DOMAINS_CONFIG"
    echo ""
    
    echo -e "${WHITE}How Trusted Domains Work:${NC}"
    echo -e "  • Emails from trusted domains receive minimal security analysis"
    echo -e "  • They bypass modules: BEC detection, typosquatting, marketing filters"
    echo -e "  • They receive a negative spam score bonus (typically -3.0 points)"
    echo -e "  • Authentication (SPF/DKIM/DMARC) is still checked"
    echo ""
    
    echo -e "${WHITE}Current Settings:${NC}"
    jq '.configuration' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null
    
    echo ""
    echo -e "${WHITE}Modules Skipped for Trusted Domains:${NC}"
    skipped=$(jq -r '.configuration.skip_modules[]' "$TRUSTED_DOMAINS_CONFIG" 2>/dev/null)
    if [[ -n "$skipped" ]]; then
        while IFS= read -r module; do
            echo -e "  ${YELLOW}•${NC} $module"
        done <<< "$skipped"
    fi
    
    echo ""
    echo -e "${WHITE}Removed Domains (with reasons):${NC}"
    echo -e "  ${RED}•${NC} gmail.com - Free email provider, shouldn't be auto-trusted"
    echo -e "  ${RED}•${NC} google.com - Should be evaluated case by case"
    
    pause_for_user
}

restore_gmail_trust() {
    show_header
    echo -e "${WHITE}Restore Gmail/Google Trust:${NC}"
    echo ""
    echo -e "${RED}⚠ WARNING: This is NOT recommended!${NC}"
    echo ""
    echo -e "${YELLOW}Gmail and Google were removed from trusted domains because:${NC}"
    echo -e "  • Free email accounts can be created by anyone"
    echo -e "  • Spammers frequently use Gmail addresses"
    echo -e "  • Each Gmail sender should be evaluated individually"
    echo ""
    echo -n -e "${RED}Are you sure you want to add Gmail/Google back? (yes/no): ${NC}"
    read confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${GREEN}Good choice - keeping Gmail/Google untrusted${NC}"
        pause_for_user
        return
    fi
    
    # Backup before modifying
    create_backup "$TRUSTED_DOMAINS_CONFIG" "Before restoring Gmail/Google"
    
    # Add both domains
    jq '.trusted_domains += ["gmail.com", "google.com"] | .trusted_domains |= unique' "$TRUSTED_DOMAINS_CONFIG" > /tmp/trusted_temp.json
    jq '.trusted_domains_notes."gmail.com" = "RESTORED - Free email provider (use with caution)" | .trusted_domains_notes."google.com" = "RESTORED - Google services (use with caution)"' /tmp/trusted_temp.json > /tmp/trusted_temp2.json
    mv /tmp/trusted_temp2.json "$TRUSTED_DOMAINS_CONFIG"
    
    echo ""
    echo -e "${YELLOW}✓ Gmail and Google have been added back to trusted domains${NC}"
    echo -e "${RED}  This may reduce spam detection effectiveness!${NC}"
    echo ""
    echo -n -e "${YELLOW}Restart postfix now? (y/n): ${NC}"
    read restart_choice
    
    if [[ "$restart_choice" == "y" || "$restart_choice" == "Y" ]]; then
        systemctl restart postfix
        echo -e "${GREEN}✓ Postfix restarted${NC}"
    fi
    
    pause_for_user
}

backup_trusted_config() {
    show_header
    echo -e "${WHITE}Backup Trusted Domains Configuration:${NC}"
    echo ""
    
    if create_backup "$TRUSTED_DOMAINS_CONFIG" "Manual backup of trusted domains"; then
        echo ""
        echo -e "${GREEN}Backup created successfully${NC}"
        echo ""
        echo -e "${WHITE}Recent backups:${NC}"
        ls -lth "$BACKUP_DIR"/trusted_domains.json.backup.* 2>/dev/null | head -5
    else
        echo -e "${RED}Failed to create backup${NC}"
    fi
    
    pause_for_user
}

# ============================================================================
# SPAMASSASSIN RULE MANAGEMENT
# ============================================================================

show_effectiveness_metrics() {
    show_header
    echo -e "${WHITE}Spam Fighting Effectiveness Metrics${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""

    # Get current effectiveness from database
    local current_metrics=$(mysql -e "
        SELECT
            metric_date,
            effectiveness_score,
            detection_rate,
            false_positive_rate,
            total_emails,
            spam_caught,
            false_positives,
            learning_rate,
            performance_rating
        FROM $DB_NAME.current_effectiveness
    " 2>/dev/null | tail -n1)

    if [[ -z "$current_metrics" ]]; then
        echo -e "${YELLOW}No effectiveness data available yet.${NC}"
        echo -e "Run the metrics calculator first:"
        echo -e "  ${CYAN}/opt/spacyserver/scripts/calculate_daily_metrics.py${NC}"
        pause_for_user
        return
    fi

    # Parse metrics
    IFS=$'\t' read -r metric_date effectiveness detection_rate fp_rate total_emails spam_caught false_positives learning_rate rating <<< "$current_metrics"

    # Convert to percentages
    effectiveness_pct=$(echo "$effectiveness" | awk '{printf "%.1f", $1}')
    detection_pct=$(echo "$detection_rate" | awk '{printf "%.1f", $1 * 100}')
    fp_pct=$(echo "$fp_rate" | awk '{printf "%.2f", $1 * 100}')
    learning_pct=$(echo "$learning_rate" | awk '{printf "%.2f", $1 * 100}')

    # Display current status
    echo -e "${WHITE}Today's Performance (${metric_date}):${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""

    # Overall effectiveness with color coding
    if (( $(echo "$effectiveness >= 85" | bc -l) )); then
        eff_color="${GREEN}"
    elif (( $(echo "$effectiveness >= 70" | bc -l) )); then
        eff_color="${YELLOW}"
    else
        eff_color="${RED}"
    fi

    echo -e "  ${WHITE}Overall Effectiveness:${NC} ${eff_color}${effectiveness_pct}%${NC} (${rating})"
    echo -e "  ${WHITE}Detection Rate:${NC} ${GREEN}${detection_pct}%${NC} (${spam_caught}/${total_emails} spam caught)"
    echo -e "  ${WHITE}False Positive Rate:${NC} ${CYAN}${fp_pct}%${NC} (${false_positives} legitimate emails blocked)"
    echo -e "  ${WHITE}Learning Rate:${NC} ${MAGENTA}${learning_pct}%${NC} weekly improvement"
    echo ""

    # Progress bar for effectiveness
    echo -e "${WHITE}Effectiveness Score:${NC}"
    local eff_int=$(echo "$effectiveness" | awk '{printf "%d", $1}')
    progress_bar $eff_int
    echo ""

    # Get 7-day trend
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}7-Day Trend:${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"

    mysql -e "
        SELECT
            metric_date as 'Date',
            ROUND(effectiveness_score, 1) as 'Score',
            ROUND(detection_rate * 100, 1) as 'Detection%',
            ROUND(false_positive_rate * 100, 2) as 'FP%',
            total_emails as 'Emails',
            spam_caught as 'Spam'
        FROM $DB_NAME.effectiveness_metrics
        WHERE metric_date >= DATE_SUB(CURDATE(), INTERVAL 6 DAY)
        ORDER BY metric_date DESC
        LIMIT 7
    " 2>/dev/null | column -t

    echo ""

    # Weekly summary
    local weekly_data=$(mysql -e "
        SELECT
            ROUND(avg_effectiveness, 1),
            total_emails,
            total_spam_caught,
            total_false_positives,
            ROUND(improvement_from_previous, 1)
        FROM $DB_NAME.effectiveness_weekly_summary
        ORDER BY week_end DESC
        LIMIT 1
    " 2>/dev/null | tail -n1)

    if [[ -n "$weekly_data" ]]; then
        IFS=$'\t' read -r week_avg week_emails week_spam week_fp improvement <<< "$weekly_data"

        echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
        echo -e "${WHITE}Weekly Summary:${NC}"
        echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
        echo -e "  ${WHITE}Average Effectiveness:${NC} ${week_avg}%"
        echo -e "  ${WHITE}Total Emails Processed:${NC} ${week_emails}"
        echo -e "  ${WHITE}Total Spam Caught:${NC} ${week_spam}"
        echo -e "  ${WHITE}Total False Positives:${NC} ${week_fp}"

        if [[ "$improvement" != "NULL" ]]; then
            if (( $(echo "$improvement > 0" | bc -l) )); then
                echo -e "  ${WHITE}Week-over-Week Change:${NC} ${GREEN}+${improvement}%${NC} ↑"
            else
                echo -e "  ${WHITE}Week-over-Week Change:${NC} ${RED}${improvement}%${NC} ↓"
            fi
        fi
        echo ""
    fi

    # Options menu
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Options:${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "  ${GREEN}1.${NC} Calculate metrics for today"
    echo -e "  ${GREEN}2.${NC} Recalculate last 7 days"
    echo -e "  ${GREEN}3.${NC} Recalculate last 30 days"
    echo -e "  ${GREEN}4.${NC} View detailed module performance"
    echo -e "  ${GREEN}5.${NC} Open web dashboard (https://100.83.45.26:5500/effectiveness)"
    echo ""
    echo -e "  ${BLUE}9.${NC} Return to Main Menu"
    echo ""
    echo -n -e "${YELLOW}Select option [1-5,9]: ${NC}"
    read choice

    case "$choice" in
        1)
            echo ""
            echo -e "${BLUE}Calculating today's metrics...${NC}"
            /opt/spacyserver/venv/bin/python3 /opt/spacyserver/scripts/calculate_daily_metrics.py
            echo ""
            pause_for_user
            show_effectiveness_metrics
            ;;
        2)
            echo ""
            echo -e "${BLUE}Recalculating last 7 days...${NC}"
            /opt/spacyserver/venv/bin/python3 /opt/spacyserver/scripts/calculate_daily_metrics.py --days-back 7
            echo ""
            pause_for_user
            show_effectiveness_metrics
            ;;
        3)
            echo ""
            echo -e "${BLUE}Recalculating last 30 days...${NC}"
            /opt/spacyserver/venv/bin/python3 /opt/spacyserver/scripts/calculate_daily_metrics.py --days-back 30
            echo ""
            pause_for_user
            show_effectiveness_metrics
            ;;
        4)
            show_module_performance
            ;;
        5)
            echo ""
            echo -e "${BLUE}Opening effectiveness dashboard...${NC}"
            echo -e "URL: ${CYAN}https://100.83.45.26:5500/effectiveness${NC}"
            echo -e "Login with your SpaCy credentials"
            pause_for_user
            ;;
        9)
            return
            ;;
        *)
            echo -e "${RED}Invalid option${NC}"
            sleep 1
            show_effectiveness_metrics
            ;;
    esac
}

show_module_performance() {
    show_header
    echo -e "${WHITE}Module Performance Details${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""

    # Get module effectiveness for today
    mysql -e "
        SELECT
            module_name as 'Module',
            triggers as 'Triggers',
            true_positives as 'True Pos',
            false_positives as 'False Pos',
            ROUND(accuracy * 100, 1) as 'Accuracy%',
            ROUND(avg_score_contribution, 2) as 'Avg Score'
        FROM $DB_NAME.module_effectiveness
        WHERE metric_date = CURDATE()
        ORDER BY triggers DESC
    " 2>/dev/null | column -t

    echo ""

    # Get 7-day module trends
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}7-Day Module Activity:${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"

    mysql -e "
        SELECT
            module_name as 'Module',
            SUM(triggers) as 'Total Triggers',
            SUM(true_positives) as 'True Positives',
            SUM(false_positives) as 'False Positives',
            ROUND(AVG(accuracy) * 100, 1) as 'Avg Accuracy%'
        FROM $DB_NAME.module_effectiveness
        WHERE metric_date >= DATE_SUB(CURDATE(), INTERVAL 6 DAY)
        GROUP BY module_name
        ORDER BY SUM(triggers) DESC
        LIMIT 10
    " 2>/dev/null | column -t

    echo ""
    pause_for_user
    show_effectiveness_metrics
}

spamassassin_rule_management() {
    while true; do
        show_header
        echo -e "${WHITE}SpamAssassin Rule Management (Quarantine Feedback):${NC}"
        echo ""
        echo -e "${YELLOW}This system analyzes quarantine releases to automatically generate${NC}"
        echo -e "${YELLOW}SpamAssassin whitelist rules for MailGuard.${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} Generate Rules from Recent Releases (7 days)"
        echo -e "${GREEN}2.${NC} Generate Rules from Extended Period (30 days)"
        echo -e "${GREEN}3.${NC} Test Rule Generation (No Deployment)"
        echo -e "${GREEN}4.${NC} View Current Generated Rules"
        echo -e "${GREEN}5.${NC} Deploy Rules to MailGuard"
        echo -e "${GREEN}6.${NC} View Quarantine Release Statistics"
        echo -e "${GREEN}7.${NC} Setup Automated Rule Updates"
        echo ""
        echo -e "${RED}0.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [0-7]: ${NC}"
        read rule_choice
        
        case "$rule_choice" in
            1)
                echo ""
                echo -e "${BLUE}Generating SpamAssassin rules from last 7 days of quarantine releases...${NC}"
                echo ""
                /opt/spacyserver/venv/bin/python3 /opt/spacyserver/tools/spamassassin_rule_generator.py --days 7
                echo ""
                pause_for_user
                ;;
            2)
                echo ""
                echo -e "${BLUE}Generating comprehensive SpamAssassin rules from last 30 days...${NC}"
                echo ""
                /opt/spacyserver/venv/bin/python3 /opt/spacyserver/tools/spamassassin_rule_generator.py --days 30
                echo ""
                pause_for_user
                ;;
            3)
                echo ""
                echo -e "${BLUE}Testing rule generation (analysis only, no deployment)...${NC}"
                echo ""
                /opt/spacyserver/venv/bin/python3 /opt/spacyserver/tools/spamassassin_rule_generator.py --test --days 7
                echo ""
                pause_for_user
                ;;
            4)
                echo ""
                echo -e "${BLUE}Current Generated SpamAssassin Rules:${NC}"
                echo ""
                if [[ -d "/opt/spacyserver/mailguard_configs/generated" ]]; then
                    latest_rules=$(ls -t /opt/spacyserver/mailguard_configs/generated/quarantine_feedback_rules_*.cf 2>/dev/null | head -1)
                    if [[ -n "$latest_rules" ]]; then
                        echo -e "${GREEN}Latest generated rules file:${NC} $latest_rules"
                        echo ""
                        head -50 "$latest_rules"
                        echo ""
                        echo -e "${YELLOW}(Showing first 50 lines - full file available at above path)${NC}"
                    else
                        echo -e "${YELLOW}No generated rules files found.${NC}"
                    fi
                else
                    echo -e "${YELLOW}Generated rules directory not found.${NC}"
                fi
                echo ""
                pause_for_user
                ;;
            5)
                echo ""
                echo -e "${BLUE}Deploying latest rules to MailGuard...${NC}"
                echo ""
                /opt/spacyserver/tools/auto_update_spamassassin.sh daily
                echo ""
                pause_for_user
                ;;
            6)
                echo ""
                echo -e "${BLUE}Quarantine Release Statistics:${NC}"
                echo ""
                mysql --defaults-file=/opt/spacyserver/config/.my.cnf $DB_NAME -e "
                SELECT 
                    COUNT(*) as total_releases,
                    COUNT(DISTINCT sender) as unique_senders,
                    AVG(trust_score) as avg_trust_score,
                    MIN(release_time) as first_release,
                    MAX(release_time) as latest_release
                FROM trusted_senders;"
                echo ""
                echo -e "${GREEN}Top 10 Most Trusted Senders:${NC}"
                mysql --defaults-file=/opt/spacyserver/config/.my.cnf $DB_NAME -e "
                SELECT sender_email, trust_score, release_count, last_subject 
                FROM trusted_senders 
                ORDER BY trust_score DESC, release_count DESC 
                LIMIT 10;"
                echo ""
                pause_for_user
                ;;
            7)
                echo ""
                echo -e "${BLUE}Setting up automated SpamAssassin rule updates...${NC}"
                echo ""
                
                # Check if crontab entry exists
                if crontab -l 2>/dev/null | grep -q "auto_update_spamassassin.sh"; then
                    echo -e "${GREEN}Automated updates are already configured.${NC}"
                    echo ""
                    echo -e "${YELLOW}Current cron schedule:${NC}"
                    crontab -l | grep auto_update_spamassassin.sh
                else
                    echo -e "${YELLOW}Adding daily automated rule updates to crontab...${NC}"
                    (crontab -l 2>/dev/null; echo "0 6 * * * /opt/spacyserver/tools/auto_update_spamassassin.sh daily >/dev/null 2>&1") | crontab -
                    (crontab -l 2>/dev/null; echo "0 2 * * 0 /opt/spacyserver/tools/auto_update_spamassassin.sh weekly >/dev/null 2>&1") | crontab -
                    echo -e "${GREEN}✓${NC} Daily rule updates scheduled for 6:00 AM"
                    echo -e "${GREEN}✓${NC} Weekly comprehensive updates scheduled for 2:00 AM Sunday"
                fi
                
                echo ""
                echo -e "${BLUE}Log file location:${NC} /opt/spacyserver/logs/spamassassin_rule_updates.log"
                echo ""
                pause_for_user
                ;;
            0)
                return
                ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

# ============================================================================
# RBL MANAGEMENT
# ============================================================================

rbl_management_menu() {
    while true; do
        show_header
        echo -e "${WHITE}RBL (Real-time Blackhole List) Management${NC}"
        echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
        echo ""

        # Show current RBL status
        echo -e "${YELLOW}Current RBL Configuration:${NC}"
        echo ""

        if [[ -f "$MODULE_CONFIG" ]]; then
            local rbl_enabled=$(jq -r '.modules.rbl_checker.enabled // false' "$MODULE_CONFIG")
            if [[ "$rbl_enabled" == "true" ]]; then
                echo -e "${GREEN}✓${NC} RBL Module: ${GREEN}ENABLED${NC}"
            else
                echo -e "${RED}✗${NC} RBL Module: ${RED}DISABLED${NC}"
            fi
        fi

        echo ""
        echo -e "${CYAN}Configured RBL Lists:${NC}"

        # Read from config file
        local rbl_config="/opt/spacyserver/config/rbl_config.json"
        if [[ -f "$rbl_config" ]]; then
            jq -r '.rbl_lists | to_entries[] | "  \(.key): \(.value.host) - Weight: \(.value.weight) [\(if .value.enabled then "ENABLED" else "DISABLED" end)]"' "$rbl_config" | while read line; do
                if [[ "$line" =~ ENABLED ]]; then
                    echo -e "${GREEN}•${NC} $line"
                else
                    echo -e "${RED}✗${NC} $line"
                fi
            done
        else
            echo -e "  ${GREEN}•${NC} SORBS (dnsbl.sorbs.net) - Weight: 3.0"
            echo -e "  ${GREEN}•${NC} SPAMHAUS (zen.spamhaus.org) - Weight: 5.0"
            echo -e "  ${GREEN}•${NC} SPAMCOP (bl.spamcop.net) - Weight: 4.0"
        fi
        echo ""

        # Get recent stats
        echo -e "${YELLOW}Recent RBL Activity (Last 24 hours):${NC}"
        local rbl_hits=$(sudo grep -i "RBL HIT" /var/log/mail.log 2>/dev/null | grep "$(date +%b\ %e)" | wc -l)
        echo -e "  Total RBL Hits: ${RED}$rbl_hits${NC}"
        echo ""

        echo -e "${WHITE}Options:${NC}"
        echo -e "${GREEN}1.${NC} View Recent RBL Hits (Last 20)"
        echo -e "${GREEN}2.${NC} Test IP Against RBLs"
        echo -e "${GREEN}3.${NC} Enable/Disable RBL Module"
        echo -e "${GREEN}4.${NC} View RBL Statistics"
        echo -e "${GREEN}5.${NC} Monitor RBL Activity (Live)"
        echo -e "${GREEN}6.${NC} Configure RBL Lists (Enable/Disable/Weights)"
        echo -e "${GREEN}7.${NC} Edit RBL Configuration File"
        echo -e "${CYAN}8.${NC} View RBL Weight Strategy Documentation"
        echo -e "${BLUE}9.${NC} Return to Main Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-9]: ${NC}"

        read choice
        case $choice in
            1) view_recent_rbl_hits ;;
            2) test_ip_rbl ;;
            3) toggle_rbl_module ;;
            4) view_rbl_statistics ;;
            5) monitor_rbl_live ;;
            6) configure_rbl_lists ;;
            7) edit_rbl_config_file ;;
            8) view_rbl_documentation ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

view_recent_rbl_hits() {
    show_header
    echo -e "${WHITE}Recent RBL Hits${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    local hits=$(sudo grep "RBL HIT" /var/log/mail.log 2>/dev/null | tail -20)

    if [[ -z "$hits" ]]; then
        echo -e "${YELLOW}No RBL hits found in recent logs.${NC}"
    else
        echo -e "${RED}Last 20 RBL Hits:${NC}"
        echo ""
        echo "$hits" | while read line; do
            # Extract IP and RBL name
            local ip=$(echo "$line" | grep -oP 'IP \K[\d.]+')
            local rbls=$(echo "$line" | grep -oP 'listed in \K\d+')
            echo -e "  ${RED}•${NC} $line"
        done
    fi

    echo ""
    echo -n "Press Enter to continue..."
    read
}

test_ip_rbl() {
    show_header
    echo -e "${WHITE}Test IP Against RBLs${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    echo -n "Enter IP address to test: "
    read test_ip

    if [[ -z "$test_ip" ]]; then
        echo -e "${RED}No IP provided.${NC}"
        sleep 2
        return
    fi

    echo ""
    echo -e "${YELLOW}Testing $test_ip against RBL lists...${NC}"
    echo ""

    /opt/spacyserver/venv/bin/python3 /opt/spacyserver/modules/rbl_checker.py "$test_ip"

    echo ""
    echo -n "Press Enter to continue..."
    read
}

toggle_rbl_module() {
    show_header
    echo -e "${WHITE}Enable/Disable RBL Module${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    if [[ ! -f "$MODULE_CONFIG" ]]; then
        echo -e "${RED}Module configuration file not found!${NC}"
        sleep 2
        return
    fi

    local rbl_enabled=$(jq -r '.modules.rbl_checker.enabled // false' "$MODULE_CONFIG")

    echo -e "Current status: $([ "$rbl_enabled" == "true" ] && echo "${GREEN}ENABLED${NC}" || echo "${RED}DISABLED${NC}")"
    echo ""

    if [[ "$rbl_enabled" == "true" ]]; then
        echo -n "Disable RBL checking? (y/n): "
        read confirm
        if [[ "$confirm" == "y" ]]; then
            create_backup "$MODULE_CONFIG" "Before disabling RBL"
            jq '.modules.rbl_checker.enabled = false' "$MODULE_CONFIG" > "${MODULE_CONFIG}.tmp"
            mv "${MODULE_CONFIG}.tmp" "$MODULE_CONFIG"
            echo -e "${GREEN}✓${NC} RBL module disabled"
            sudo systemctl restart postfix
            echo -e "${BLUE}Postfix restarted${NC}"
        fi
    else
        echo -n "Enable RBL checking? (y/n): "
        read confirm
        if [[ "$confirm" == "y" ]]; then
            create_backup "$MODULE_CONFIG" "Before enabling RBL"
            jq '.modules.rbl_checker.enabled = true' "$MODULE_CONFIG" > "${MODULE_CONFIG}.tmp"
            mv "${MODULE_CONFIG}.tmp" "$MODULE_CONFIG"
            echo -e "${GREEN}✓${NC} RBL module enabled"
            sudo systemctl restart postfix
            echo -e "${BLUE}Postfix restarted${NC}"
        fi
    fi

    echo ""
    echo -n "Press Enter to continue..."
    read
}

view_rbl_statistics() {
    show_header
    echo -e "${WHITE}RBL Statistics${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    echo -e "${YELLOW}Last 7 Days RBL Activity:${NC}"
    echo ""

    for i in {0..6}; do
        local check_date=$(date -d "$i days ago" "+%b %e")
        local hits=$(sudo grep "RBL HIT" /var/log/mail.log 2>/dev/null | grep "$check_date" | wc -l)
        echo -e "  $check_date: ${RED}$hits${NC} hits"
    done

    echo ""
    echo -e "${YELLOW}RBL Breakdown (Last 24 hours):${NC}"
    echo ""

    local sorbs=$(sudo grep "RBL HIT" /var/log/mail.log 2>/dev/null | grep "$(date +%b\ %e)" | grep -i "SORBS" | wc -l)
    local spamhaus=$(sudo grep "RBL HIT" /var/log/mail.log 2>/dev/null | grep "$(date +%b\ %e)" | grep -i "SPAMHAUS" | wc -l)
    local spamcop=$(sudo grep "RBL HIT" /var/log/mail.log 2>/dev/null | grep "$(date +%b\ %e)" | grep -i "SPAMCOP" | wc -l)

    echo -e "  ${GREEN}SORBS:${NC} $sorbs hits"
    echo -e "  ${GREEN}SPAMHAUS:${NC} $spamhaus hits"
    echo -e "  ${GREEN}SPAMCOP:${NC} $spamcop hits"

    echo ""
    echo -n "Press Enter to continue..."
    read
}

configure_rbl_lists() {
    show_header
    echo -e "${WHITE}Configure RBL Lists${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    local rbl_config="/opt/spacyserver/config/rbl_config.json"

    if [[ ! -f "$rbl_config" ]]; then
        echo -e "${RED}RBL configuration file not found!${NC}"
        echo ""
        echo -n "Press Enter to continue..."
        read
        return
    fi

    # Show current RBL lists
    echo -e "${YELLOW}Current RBL Lists:${NC}"
    echo ""

    local rbl_names=($(jq -r '.rbl_lists | keys[]' "$rbl_config"))
    local count=1

    for rbl_name in "${rbl_names[@]}"; do
        local host=$(jq -r ".rbl_lists.\"$rbl_name\".host" "$rbl_config")
        local weight=$(jq -r ".rbl_lists.\"$rbl_name\".weight" "$rbl_config")
        local enabled=$(jq -r ".rbl_lists.\"$rbl_name\".enabled" "$rbl_config")
        local description=$(jq -r ".rbl_lists.\"$rbl_name\".description" "$rbl_config")

        if [[ "$enabled" == "true" ]]; then
            echo -e "${GREEN}$count.${NC} ${GREEN}[ENABLED]${NC}  $rbl_name"
        else
            echo -e "${RED}$count.${NC} ${RED}[DISABLED]${NC} $rbl_name"
        fi
        echo -e "    Host: $host"
        echo -e "    Weight: $weight points"
        echo -e "    Description: $description"
        echo ""
        ((count++))
    done

    echo -n "Select RBL to modify (1-${#rbl_names[@]}) or 0 to cancel: "
    read selection

    if [[ "$selection" == "0" || -z "$selection" ]]; then
        return
    fi

    if [[ "$selection" -lt 1 || "$selection" -gt "${#rbl_names[@]}" ]]; then
        echo -e "${RED}Invalid selection.${NC}"
        sleep 2
        return
    fi

    local selected_rbl="${rbl_names[$((selection-1))]}"
    local current_enabled=$(jq -r ".rbl_lists.\"$selected_rbl\".enabled" "$rbl_config")
    local current_weight=$(jq -r ".rbl_lists.\"$selected_rbl\".weight" "$rbl_config")

    echo ""
    echo -e "${CYAN}Modifying: $selected_rbl${NC}"
    echo ""
    echo "1. Toggle Enable/Disable (currently: $current_enabled)"
    echo "2. Change Weight (currently: $current_weight)"
    echo "3. Cancel"
    echo ""
    echo -n "Select action: "
    read action

    case $action in
        1)
            create_backup "$rbl_config" "Before toggling $selected_rbl"
            local new_enabled
            if [[ "$current_enabled" == "true" ]]; then
                new_enabled="false"
            else
                new_enabled="true"
            fi
            jq ".rbl_lists.\"$selected_rbl\".enabled = $new_enabled" "$rbl_config" > "${rbl_config}.tmp"
            mv "${rbl_config}.tmp" "$rbl_config"
            echo -e "${GREEN}✓${NC} $selected_rbl $([ "$new_enabled" == "true" ] && echo "enabled" || echo "disabled")"
            echo -e "${BLUE}Restarting Postfix to apply changes...${NC}"
            sudo systemctl restart postfix
            ;;
        2)
            echo -n "Enter new weight (current: $current_weight): "
            read new_weight
            if [[ "$new_weight" =~ ^[0-9]+\.?[0-9]*$ ]]; then
                create_backup "$rbl_config" "Before changing $selected_rbl weight"
                jq ".rbl_lists.\"$selected_rbl\".weight = $new_weight" "$rbl_config" > "${rbl_config}.tmp"
                mv "${rbl_config}.tmp" "$rbl_config"
                echo -e "${GREEN}✓${NC} $selected_rbl weight changed to $new_weight"
                echo -e "${BLUE}Restarting Postfix to apply changes...${NC}"
                sudo systemctl restart postfix
            else
                echo -e "${RED}Invalid weight value.${NC}"
            fi
            ;;
        *)
            return
            ;;
    esac

    echo ""
    echo -n "Press Enter to continue..."
    read
}

edit_rbl_config_file() {
    show_header
    echo -e "${WHITE}Edit RBL Configuration File${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""

    local rbl_config="/opt/spacyserver/config/rbl_config.json"

    if [[ ! -f "$rbl_config" ]]; then
        echo -e "${RED}RBL configuration file not found!${NC}"
        echo ""
        echo -n "Press Enter to continue..."
        read
        return
    fi

    echo -e "${YELLOW}Current configuration file: $rbl_config${NC}"
    echo ""
    echo -e "${CYAN}This will open the file in your default editor (nano/vi).${NC}"
    echo -e "${RED}WARNING: Manual edits can break JSON formatting!${NC}"
    echo ""
    echo -n "Continue? (y/n): "
    read confirm

    if [[ "$confirm" != "y" ]]; then
        return
    fi

    create_backup "$rbl_config" "Before manual edit"

    ${EDITOR:-nano} "$rbl_config"

    # Validate JSON after editing
    if jq empty "$rbl_config" 2>/dev/null; then
        echo -e "${GREEN}✓${NC} Configuration file is valid JSON"
        echo -e "${BLUE}Restarting Postfix to apply changes...${NC}"
        sudo systemctl restart postfix
    else
        echo -e "${RED}✗${NC} JSON validation failed!"
        echo -e "${YELLOW}Restoring from backup...${NC}"
        local latest_backup=$(ls -t "$BACKUP_DIR"/rbl_config.json.backup.* 2>/dev/null | head -1)
        if [[ -n "$latest_backup" ]]; then
            cp "$latest_backup" "$rbl_config"
            echo -e "${GREEN}✓${NC} Restored from backup"
        fi
    fi

    echo ""
    echo -n "Press Enter to continue..."
    read
}

monitor_rbl_live() {
    show_header
    echo -e "${WHITE}Live RBL Activity Monitor${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${YELLOW}Monitoring RBL hits in real-time... (Ctrl+C to stop)${NC}"
    echo ""

    sudo tail -f /var/log/mail.log | grep --line-buffered -i "rbl"
}

view_rbl_documentation() {
    while true; do
        show_header
        echo -e "${WHITE}RBL Documentation${NC}"
        echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
        echo ""

        echo -e "${CYAN}Available Documentation:${NC}"
        echo ""
        echo -e "${GREEN}1.${NC} View RBL Weight Strategy (Full Guide)"
        echo -e "${GREEN}2.${NC} View Quick Reference Card"
        echo -e "${GREEN}3.${NC} View Configuration File Location"
        echo -e "${BLUE}9.${NC} Return to RBL Menu"
        echo ""
        echo -n -e "${YELLOW}Select option [1-3,9]: ${NC}"

        read doc_choice
        case $doc_choice in
            1)
                show_header
                echo -e "${WHITE}RBL Weight Strategy Documentation${NC}"
                echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
                echo ""

                if [[ -f "/opt/spacyserver/docs/RBL_Weight_Strategy.md" ]]; then
                    less /opt/spacyserver/docs/RBL_Weight_Strategy.md
                else
                    echo -e "${RED}Documentation file not found!${NC}"
                    echo ""
                    echo -n "Press Enter to continue..."
                    read
                fi
                ;;
            2)
                show_header
                echo -e "${WHITE}RBL Quick Reference Card${NC}"
                echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
                echo ""

                if [[ -f "/opt/spacyserver/docs/RBL_Quick_Reference.txt" ]]; then
                    cat /opt/spacyserver/docs/RBL_Quick_Reference.txt
                    echo ""
                    echo -n "Press Enter to continue..."
                    read
                else
                    echo -e "${RED}Quick reference file not found!${NC}"
                    echo ""
                    echo -n "Press Enter to continue..."
                    read
                fi
                ;;
            3)
                show_header
                echo -e "${WHITE}RBL File Locations${NC}"
                echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
                echo ""

                echo -e "${YELLOW}Configuration Files:${NC}"
                echo ""
                echo -e "${CYAN}RBL Configuration:${NC}"
                echo -e "  /opt/spacyserver/config/rbl_config.json"
                echo ""
                echo -e "${CYAN}Module Configuration:${NC}"
                echo -e "  /opt/spacyserver/config/module_config.json"
                echo ""
                echo -e "${CYAN}RBL Checker Module:${NC}"
                echo -e "  /opt/spacyserver/modules/rbl_checker.py"
                echo ""
                echo -e "${CYAN}MailGuard SpamAssassin Rules:${NC}"
                echo -e "  /opt/spacyserver/mailguard_configs/spacy_rbl.cf"
                echo ""
                echo -e "${YELLOW}Documentation Files:${NC}"
                echo ""
                echo -e "${CYAN}Full Strategy Guide:${NC}"
                echo -e "  /opt/spacyserver/docs/RBL_Weight_Strategy.md"
                echo ""
                echo -e "${CYAN}Quick Reference:${NC}"
                echo -e "  /opt/spacyserver/docs/RBL_Quick_Reference.txt"
                echo ""
                echo -e "${YELLOW}Log Files:${NC}"
                echo ""
                echo -e "${CYAN}Main Email Log:${NC}"
                echo -e "  /var/log/mail.log"
                echo ""
                echo -e "${CYAN}View RBL hits:${NC}"
                echo -e "  sudo tail -f /var/log/mail.log | grep -i rbl"
                echo ""
                echo -n "Press Enter to continue..."
                read
                ;;
            9)
                return
                ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    while true; do
        show_main_menu
        read choice

        case $choice in
            1)
                echo ""
                echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${RED}⚠️  DEPRECATED: BEC Sender Whitelist (bec_config.json)${NC}"
                echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${YELLOW}This feature will be removed in v1.7.0${NC}"
                echo ""
                echo -e "${BLUE}Please use SpacyWeb for whitelist management:${NC}"
                echo -e "  • Users/Domain Admins: Whitelist Management in SpacyWeb GUI"
                echo -e "  • Superadmins: Trusted Domains Management (Option 18)"
                echo ""
                echo -n -e "${YELLOW}Press Enter to continue anyway, or Ctrl+C to go back: ${NC}"
                read
                bec_sender_menu
                ;;
            2)
                echo ""
                echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${RED}⚠️  DEPRECATED: BEC Domain Whitelist (bec_config.json)${NC}"
                echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${YELLOW}This feature will be removed in v1.7.0${NC}"
                echo ""
                echo -e "${BLUE}Please use SpacyWeb for whitelist management:${NC}"
                echo -e "  • Users/Domain Admins: Whitelist Management in SpacyWeb GUI"
                echo -e "  • Superadmins: Trusted Domains Management (Option 18)"
                echo ""
                echo -n -e "${YELLOW}Press Enter to continue anyway, or Ctrl+C to go back: ${NC}"
                read
                bec_domain_menu
                ;;
            3) executive_protection_menu ;;
            4) company_impersonation_menu ;;
            5) email_filter_menu ;;
            6) authentication_menu ;;
            7) threshold_menu ;;
            8) performance_monitoring_menu ;;
            9) realtime_analysis_menu ;;
            10) backup_restore_menu ;;
            11) system_info ;;
            12) validate_and_fix_json_menu ;;
            13) check_permissions_menu ;;
            14) /opt/spacyserver/tools/domain_manager.sh ;;
            15) dns_diagnostics_menu ;;
            16)
                clear
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo -e "${RED}⚠️  MTA-LEVEL BLOCKING IS CURRENTLY DISABLED${NC}"
                echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
                echo ""
                echo -e "${BLUE}Country and domain blocking is now handled via spam score penalties${NC}"
                echo -e "${BLUE}instead of MTA-level hard blocking. This provides:${NC}"
                echo ""
                echo -e "  ${GREEN}✓${NC} Better visibility in the web GUI"
                echo -e "  ${GREEN}✓${NC} Allows Domain Admins to release legitimate emails"
                echo -e "  ${GREEN}✓${NC} 30-day quarantine with full email storage"
                echo -e "  ${GREEN}✓${NC} Clear spam score breakdown showing why emails were blocked"
                echo ""
                echo -e "${YELLOW}Current Country Blocking:${NC}"
                echo -e "  High-risk countries (CN, HK, RU, KP, IR, NG, VN, ID, PK, BD, UA)"
                echo -e "  receive +50 spam points, quarantining them for admin review."
                echo ""
                echo -e "${BLUE}The blocking manager tool is still available but not actively used.${NC}"
                echo -e "${BLUE}To re-enable MTA blocking, see email_filter.py lines 2739-2776.${NC}"
                echo ""
                echo -n -e "${YELLOW}Press Enter to launch blocking manager anyway, or Ctrl+C to cancel: ${NC}"
                read
                /opt/spacyserver/tools/blocking_manager.sh
                ;;
            17) search_email_by_sender ;;
            18) trusted_domains_menu ;;
            19) unified_whitelist_search ;;
            20) conversation_learning_stats ;;
            21) spamassassin_rule_management ;;
            22) show_effectiveness_metrics ;;
            23) rbl_management_menu ;;
            0)
                clear
                echo -e "${GREEN}Thank you for using Enhanced OpenSpaCy Admin Menu!${NC}"
                echo -e "${BLUE}Email security management complete.${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option. Please try again.${NC}"
                sleep 1
                ;;
        esac
    done
}

# ============================================================================
# CONVERSATION LEARNING STATISTICS
# ============================================================================

conversation_learning_stats() {
    show_header
    echo -e "${WHITE}🧠 Conversation Learning Statistics${NC}"
    echo ""
    
    # Check if user wants to feed an email to learning
    echo -e "${CYAN}Options:${NC}"
    echo -e "  ${GREEN}1.${NC} View learning statistics"
    echo -e "  ${GREEN}2.${NC} Feed good email to learning system (by Message-ID)"
    echo -e "  ${GREEN}3.${NC} Search and feed recent email"
    echo ""
    echo -n -e "${YELLOW}Select option [1-3]: ${NC}"
    read learning_choice
    
    case "$learning_choice" in
        2)
            feed_email_to_learning
            return
            ;;
        3)
            search_and_feed_email
            return
            ;;
        1|"")
            # Continue with stats display
            ;;
        *)
            echo -e "${RED}Invalid option${NC}"
            sleep 1
            return
            ;;
    esac
    
    # Get statistics using external Python script
    stats_output=$($PYTHON /opt/spacyserver/scripts/get_learning_stats.py 2>/dev/null)
    
    if [[ -z "$stats_output" ]]; then
        echo -e "${RED}Error reading learning statistics${NC}"
        echo -e "Press any key to return to main menu..."
        read -n 1
        return
    fi
    
    # Parse statistics
    vocabulary=$(echo "$stats_output" | jq -r '.vocabulary // 0')
    relationships=$(echo "$stats_output" | jq -r '.relationships // 0')
    phrases=$(echo "$stats_output" | jq -r '.phrases // 0')
    domains=$(echo "$stats_output" | jq -r '.domains // 0')
    confidence=$(echo "$stats_output" | jq -r '.confidence // 0' | cut -d. -f1)
    new_patterns=$(echo "$stats_output" | jq -r '.new_patterns_24h // 0')
    avg_messages=$(echo "$stats_output" | jq -r '.avg_messages // 0' | cut -d. -f1)
    
    # Display overview with progress bars
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Learning Progress Overview${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Vocabulary progress
    echo -e "${WHITE}Vocabulary Patterns:${NC} $vocabulary"
    vocab_percent=$((vocabulary * 100 / 1000))
    [[ $vocab_percent -gt 100 ]] && vocab_percent=100
    progress_bar $vocab_percent
    echo ""
    
    # Relationships progress
    echo -e "${WHITE}Domain Relationships:${NC} $relationships"
    rel_percent=$((relationships * 100 / 50))
    [[ $rel_percent -gt 100 ]] && rel_percent=100
    progress_bar $rel_percent
    echo ""
    
    # Overall confidence
    echo -e "${WHITE}System Confidence:${NC} ${confidence}%"
    progress_bar $confidence
    echo ""
    
    # Learning activity
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Learning Activity (Last 24 Hours)${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "  New patterns learned: ${GREEN}$new_patterns${NC}"
    echo -e "  Client domains tracked: ${GREEN}$domains${NC}"
    echo -e "  Professional phrases identified: ${GREEN}$phrases${NC}"
    echo -e "  Average messages per domain: ${GREEN}$avg_messages${NC}"
    echo ""
    
    # Top relationships
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Top Communication Patterns${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    
    top_relationships=$(echo "$stats_output" | jq -r '.top_relationships[] | @json' 2>/dev/null)
    if [[ -n "$top_relationships" ]]; then
        i=1
        echo "$top_relationships" | while read -r rel; do
            sender=$(echo "$rel" | jq -r '.[0]')
            recipient=$(echo "$rel" | jq -r '.[1]')
            count=$(echo "$rel" | jq -r '.[2]')
            avg_spam=$(echo "$rel" | jq -r '.[3]' | cut -d. -f1,2)
            
            echo -e "  ${i}. ${YELLOW}$sender${NC} → ${YELLOW}$recipient${NC}"
            echo -e "     Messages: $count | Avg Spam Score: $avg_spam"
            ((i++))
            [[ $i -gt 5 ]] && break
        done
    else
        echo -e "  ${YELLOW}No relationships established yet${NC}"
    fi
    echo ""
    
    # Common phrases
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Most Common Professional Phrases${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    
    top_phrases=$(echo "$stats_output" | jq -r '.top_phrases[] | @json' 2>/dev/null)
    if [[ -n "$top_phrases" ]]; then
        echo "$top_phrases" | while read -r phrase_data; do
            phrase=$(echo "$phrase_data" | jq -r '.[0]')
            freq=$(echo "$phrase_data" | jq -r '.[1]')
            echo -e "  • \"${GREEN}$phrase${NC}\" (seen $freq times)"
        done
    else
        echo -e "  ${YELLOW}Learning professional language patterns...${NC}"
    fi
    echo ""
    
    # Effectiveness prediction
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}System Effectiveness${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    
    if [[ $confidence -lt 20 ]]; then
        echo -e "  Status: ${YELLOW}Initial Learning Phase${NC}"
        echo -e "  • System is gathering baseline patterns"
        echo -e "  • Minimal spam score adjustments (±0.5 points)"
        echo -e "  • Expected confidence in: 3-5 days"
    elif [[ $confidence -lt 50 ]]; then
        echo -e "  Status: ${BLUE}Active Learning${NC}"
        echo -e "  • Recognizing common communication patterns"
        echo -e "  • Moderate spam score adjustments (±1.0 points)"
        echo -e "  • Full effectiveness in: 1-2 weeks"
    elif [[ $confidence -lt 80 ]]; then
        echo -e "  Status: ${GREEN}Effective${NC}"
        echo -e "  • Strong pattern recognition"
        echo -e "  • Significant spam score adjustments (±1.5 points)"
        echo -e "  • Reducing false positives effectively"
    else
        echo -e "  Status: ${GREEN}${BOLD}Highly Effective${NC}"
        echo -e "  • Excellent pattern recognition"
        echo -e "  • Maximum spam score adjustments (±2.0 points)"
        echo -e "  • Optimal false positive reduction"
    fi
    echo ""
    
    # Headers to check
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}Email Headers Added by Learning System${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "  ${GREEN}X-Conversation-Pattern-Adjustment:${NC} Score change applied"
    echo -e "  ${GREEN}X-Conversation-Legitimacy:${NC} Pattern match score (0-1)"
    echo -e "  ${GREEN}X-Learning-Confidence:${NC} System confidence (0-1)"
    echo ""
    
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "Press any key to return to main menu..."
    read -n 1
}

# Helper function for progress bars
progress_bar() {
    local percent=$1
    local width=40
    local filled=$((percent * width / 100))
    local empty=$((width - filled))
    
    echo -n "  ["
    if [[ $percent -lt 30 ]]; then
        color=$RED
    elif [[ $percent -lt 70 ]]; then
        color=$YELLOW
    else
        color=$GREEN
    fi
    
    printf "${color}%${filled}s${NC}" | tr ' ' '█'
    printf "%${empty}s" | tr ' ' '░'
    echo "] ${percent}%"
}

# Feed email to learning system by Message-ID
feed_email_to_learning() {
    show_header
    echo -e "${WHITE}Feed Email to Learning System${NC}"
    echo ""
    
    echo -e "${CYAN}This will mark an email as 'good' and use it to train the learning system.${NC}"
    echo -e "${YELLOW}Only use this for legitimate emails that were incorrectly flagged!${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter Message-ID (or partial ID): ${NC}"
    read message_id
    
    if [[ -z "$message_id" ]]; then
        echo -e "${RED}Message-ID cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    # Clean up the message ID (remove angle brackets if present)
    message_id="${message_id#<}"
    message_id="${message_id%>}"
    
    echo ""
    echo -n -e "${YELLOW}Override spam score? (leave blank to use original, or enter 0-10): ${NC}"
    read override_score
    
    echo ""
    echo -e "${BLUE}Feeding email to learning system...${NC}"
    echo ""
    
    if [[ -n "$override_score" ]]; then
        result=$($PYTHON /opt/spacyserver/scripts/feed_email_by_id.py "$message_id" "$override_score" 2>&1)
    else
        result=$($PYTHON /opt/spacyserver/scripts/feed_email_by_id.py "$message_id" 2>&1)
    fi
    
    echo "$result"
    echo ""
    pause_for_user
}

# Search for recent emails and feed to learning
search_and_feed_email() {
    show_header
    echo -e "${WHITE}Search and Feed Recent Email${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Enter sender email or domain: ${NC}"
    read sender_search
    
    if [[ -z "$sender_search" ]]; then
        echo -e "${RED}Search term cannot be empty${NC}"
        pause_for_user
        return
    fi
    
    echo ""
    echo -e "${BLUE}Searching for recent emails from $sender_search...${NC}"
    echo ""
    
    # Search in database for recent emails
    search_query="SELECT message_id, sender, recipients, subject, spam_score, 
                         DATE_FORMAT(timestamp, '%Y-%m-%d %H:%i') as time
                  FROM email_analysis 
                  WHERE sender LIKE '%$sender_search%' 
                  ORDER BY timestamp DESC 
                  LIMIT 10"
    
    results=$(sudo -u spacy-filter mysql --defaults-file=/opt/spacyserver/config/.my.cnf \
              $DB_NAME -e "$search_query" 2>/dev/null | tail -n +2)
    
    if [[ -z "$results" ]]; then
        echo -e "${RED}No emails found from $sender_search${NC}"
        pause_for_user
        return
    fi
    
    echo -e "${GREEN}Recent emails:${NC}"
    echo ""
    
    # Display results with line numbers
    IFS=$'\n'
    counter=1
    declare -a message_ids
    
    for line in $results; do
        message_id=$(echo "$line" | cut -f1)
        sender=$(echo "$line" | cut -f2)
        subject=$(echo "$line" | cut -f4 | cut -c1-40)
        spam_score=$(echo "$line" | cut -f5)
        time=$(echo "$line" | cut -f6)
        
        message_ids[$counter]="$message_id"
        
        printf "%2d) %-20s | Score: %4s | %s | %.40s\n" \
               "$counter" "$time" "$spam_score" "$sender" "$subject"
        
        ((counter++))
    done
    
    echo ""
    echo -n -e "${YELLOW}Select email number to feed (or 0 to cancel): ${NC}"
    read selection
    
    if [[ "$selection" == "0" ]] || [[ -z "$selection" ]]; then
        return
    fi
    
    if [[ "$selection" -lt 1 ]] || [[ "$selection" -gt ${#message_ids[@]} ]]; then
        echo -e "${RED}Invalid selection${NC}"
        pause_for_user
        return
    fi
    
    selected_id="${message_ids[$selection]}"
    
    echo ""
    echo -n -e "${YELLOW}Override spam score? (leave blank to use original): ${NC}"
    read override_score
    
    echo ""
    echo -e "${BLUE}Feeding email to learning system...${NC}"
    echo ""
    
    if [[ -n "$override_score" ]]; then
        result=$($PYTHON /opt/spacyserver/scripts/feed_email_by_id.py "$selected_id" "$override_score" 2>&1)
    else  
        result=$($PYTHON /opt/spacyserver/scripts/feed_email_by_id.py "$selected_id" 2>&1)
    fi
    
    echo "$result"
    echo ""
    pause_for_user
}

# Run main function
main "$@"
